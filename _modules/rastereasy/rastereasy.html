

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>rastereasy.rastereasy &mdash; rastereasy 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/myst_sphinx_gallery.css?v=92de7a9e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            rastereasy
              <img src="../../_static/logo_er.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../rastereasy.html">Rastereasy Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../rastereasy.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rastereasy.html#using-and-citing-the-toolbox">Using and citing the toolbox</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rastereasy.html#some-interesting-functions">Some interesting functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rastereasy.html#resampling-function">Resampling Function</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.resampling"><code class="docutils literal notranslate"><span class="pre">resampling()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rastereasy.html#projection-function">Projection Function</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.reproject"><code class="docutils literal notranslate"><span class="pre">reproject()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rastereasy.html#cropping-function">Cropping Function</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.crop"><code class="docutils literal notranslate"><span class="pre">crop()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rastereasy.html#machine-learning">Machine Learning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.kmeans"><code class="docutils literal notranslate"><span class="pre">kmeans()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.apply_ML_model"><code class="docutils literal notranslate"><span class="pre">apply_ML_model()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rastereasy.html#band-manipulation">Band manipulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.stack"><code class="docutils literal notranslate"><span class="pre">stack()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.reorder_bands"><code class="docutils literal notranslate"><span class="pre">reorder_bands()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.remove_bands"><code class="docutils literal notranslate"><span class="pre">remove_bands()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rastereasy.html#access-to-numpy">Access to numpy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.numpy_channel_first"><code class="docutils literal notranslate"><span class="pre">numpy_channel_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.numpy_channel_last"><code class="docutils literal notranslate"><span class="pre">numpy_channel_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.image_from_table"><code class="docutils literal notranslate"><span class="pre">image_from_table()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rastereasy.html#processing-on-images">Processing on images</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#rastereasy.Geoimage.adapt"><code class="docutils literal notranslate"><span class="pre">adapt()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rastereasy.html#id0"><code class="docutils literal notranslate"><span class="pre">image_from_table()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../rastereasy.html#additional-notes">Additional Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#with-pip">With pip</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#from-source">From source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#note-for-jupyter-lab-users">Note for jupyter-lab users</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick Start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Releases</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../releases.html#id1">0.1.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../releases.html#id2">0.1.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code.html">Licence, Code of conduct &amp; source code</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../my_html_gallery.html">Examples of rastereasy use</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#data-for-notebooks">Data for notebooks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#quick-start">00 Quick Start</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#read-and-plot">01 Read And Plot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#plot-spectral-bands-and-get-pixel-values">02 Plot Spectral Bands And Get Pixel Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#crop-image">03 Crop Image</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#reprojection">04 Reprojection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#resample">05 Resample</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#deal-with-numpy-arrays">06 Deal With Numpy Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#save-images">07 Save Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#standardization-of-bands">08 Standardization Of Bands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#select-bands">09 Select Bands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#pixel-vs-geo-coord">10 Pixel Vs Geo Coord</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#demo-add-bands">11 Demo Add Bands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#remove-bands">12 Remove Bands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#stack-images">13 Stack Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#deal-with-bounding-boxes">14 Deal With Bounding Boxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#extract-from-shp">15 Extract From Shp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#ex-compute-ndvi">16 Ex Compute Ndvi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#demo-adapt-bands-with-ot">17 Demo Adapt Bands With Ot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#ex-kmeans">18 Ex Kmeans</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#fusion-dempster-shafer-2hypotheses">19 Fusion Dempster Shafer 2Hypotheses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_html_gallery.html#prepare-snippets-data-for-training">20 Prepare Snippets Data For Training</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Classes of rastereasy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage"><code class="docutils literal notranslate"><span class="pre">Geoimage</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.__init__"><code class="docutils literal notranslate"><span class="pre">Geoimage.__init__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.where"><code class="docutils literal notranslate"><span class="pre">Geoimage.where()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.update_from"><code class="docutils literal notranslate"><span class="pre">Geoimage.update_from()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.reset_names"><code class="docutils literal notranslate"><span class="pre">Geoimage.reset_names()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.change_nodata"><code class="docutils literal notranslate"><span class="pre">Geoimage.change_nodata()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.change_names"><code class="docutils literal notranslate"><span class="pre">Geoimage.change_names()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.activate_history"><code class="docutils literal notranslate"><span class="pre">Geoimage.activate_history()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.deactivate_history"><code class="docutils literal notranslate"><span class="pre">Geoimage.deactivate_history()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.copy"><code class="docutils literal notranslate"><span class="pre">Geoimage.copy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.info"><code class="docutils literal notranslate"><span class="pre">Geoimage.info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_type"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_type()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_spatial_resolution"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_spatial_resolution()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_latlon_coordinates"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_latlon_coordinates()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_size"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_size()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_nb_bands"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_nb_bands()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_meta"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_meta()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_nodata"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_nodata()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_bounds"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_bounds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_names"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_names()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.get_georef"><code class="docutils literal notranslate"><span class="pre">Geoimage.get_georef()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.unique"><code class="docutils literal notranslate"><span class="pre">Geoimage.unique()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.abs"><code class="docutils literal notranslate"><span class="pre">Geoimage.abs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.sum"><code class="docutils literal notranslate"><span class="pre">Geoimage.sum()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.min"><code class="docutils literal notranslate"><span class="pre">Geoimage.min()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.max"><code class="docutils literal notranslate"><span class="pre">Geoimage.max()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.mean"><code class="docutils literal notranslate"><span class="pre">Geoimage.mean()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.std"><code class="docutils literal notranslate"><span class="pre">Geoimage.std()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.median"><code class="docutils literal notranslate"><span class="pre">Geoimage.median()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.replace_values"><code class="docutils literal notranslate"><span class="pre">Geoimage.replace_values()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.percentage_pixels"><code class="docutils literal notranslate"><span class="pre">Geoimage.percentage_pixels()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.hist"><code class="docutils literal notranslate"><span class="pre">Geoimage.hist()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.colorcomp"><code class="docutils literal notranslate"><span class="pre">Geoimage.colorcomp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.convert_3bands"><code class="docutils literal notranslate"><span class="pre">Geoimage.convert_3bands()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.plot_spectra"><code class="docutils literal notranslate"><span class="pre">Geoimage.plot_spectra()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.visu"><code class="docutils literal notranslate"><span class="pre">Geoimage.visu()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.numpy_channel_first"><code class="docutils literal notranslate"><span class="pre">Geoimage.numpy_channel_first()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.numpy_channel_last"><code class="docutils literal notranslate"><span class="pre">Geoimage.numpy_channel_last()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.numpy_table"><code class="docutils literal notranslate"><span class="pre">Geoimage.numpy_table()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.image_from_table"><code class="docutils literal notranslate"><span class="pre">Geoimage.image_from_table()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.upload_table"><code class="docutils literal notranslate"><span class="pre">Geoimage.upload_table()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.upload_image"><code class="docutils literal notranslate"><span class="pre">Geoimage.upload_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.astype"><code class="docutils literal notranslate"><span class="pre">Geoimage.astype()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.reproject"><code class="docutils literal notranslate"><span class="pre">Geoimage.reproject()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.latlon2pixel"><code class="docutils literal notranslate"><span class="pre">Geoimage.latlon2pixel()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.pixel2latlon"><code class="docutils literal notranslate"><span class="pre">Geoimage.pixel2latlon()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.save"><code class="docutils literal notranslate"><span class="pre">Geoimage.save()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.extract_from_shapefile"><code class="docutils literal notranslate"><span class="pre">Geoimage.extract_from_shapefile()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.extract_from_shapeimage"><code class="docutils literal notranslate"><span class="pre">Geoimage.extract_from_shapeimage()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.kmeans"><code class="docutils literal notranslate"><span class="pre">Geoimage.kmeans()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.apply_ML_model"><code class="docutils literal notranslate"><span class="pre">Geoimage.apply_ML_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.adapt"><code class="docutils literal notranslate"><span class="pre">Geoimage.adapt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.fuse_dempster_shafer_2"><code class="docutils literal notranslate"><span class="pre">Geoimage.fuse_dempster_shafer_2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.standardize"><code class="docutils literal notranslate"><span class="pre">Geoimage.standardize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.inverse_standardize"><code class="docutils literal notranslate"><span class="pre">Geoimage.inverse_standardize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.resampling"><code class="docutils literal notranslate"><span class="pre">Geoimage.resampling()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.crop"><code class="docutils literal notranslate"><span class="pre">Geoimage.crop()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.select_bands"><code class="docutils literal notranslate"><span class="pre">Geoimage.select_bands()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.stack"><code class="docutils literal notranslate"><span class="pre">Geoimage.stack()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.remove_bands"><code class="docutils literal notranslate"><span class="pre">Geoimage.remove_bands()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.reorder_bands"><code class="docutils literal notranslate"><span class="pre">Geoimage.reorder_bands()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.switch_band"><code class="docutils literal notranslate"><span class="pre">Geoimage.switch_band()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Geoimage.add_band"><code class="docutils literal notranslate"><span class="pre">Geoimage.add_band()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#rastereasy.shpfiles"><code class="docutils literal notranslate"><span class="pre">shpfiles</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.shpfiles.get_shapefile_attributes"><code class="docutils literal notranslate"><span class="pre">shpfiles.get_shapefile_attributes()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.shpfiles.shp2geoim"><code class="docutils literal notranslate"><span class="pre">shpfiles.shp2geoim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.shpfiles.shp2raster"><code class="docutils literal notranslate"><span class="pre">shpfiles.shp2raster()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#rastereasy.InferenceTools"><code class="docutils literal notranslate"><span class="pre">InferenceTools</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.InferenceTools.kmeans"><code class="docutils literal notranslate"><span class="pre">InferenceTools.kmeans()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.InferenceTools.fuse_dempster_shafer_2hypotheses"><code class="docutils literal notranslate"><span class="pre">InferenceTools.fuse_dempster_shafer_2hypotheses()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.InferenceTools.adapt"><code class="docutils literal notranslate"><span class="pre">InferenceTools.adapt()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#rastereasy.rasters"><code class="docutils literal notranslate"><span class="pre">rasters</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.rasters.stack"><code class="docutils literal notranslate"><span class="pre">rasters.stack()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.rasters.remove_bands"><code class="docutils literal notranslate"><span class="pre">rasters.remove_bands()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#rastereasy.Visualizer"><code class="docutils literal notranslate"><span class="pre">Visualizer</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#rastereasy.Visualizer.plot_spectra"><code class="docutils literal notranslate"><span class="pre">Visualizer.plot_spectra()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">rastereasy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">rastereasy.rastereasy</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for rastereasy.rastereasy</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core module for the rastereasy package.</span>
<span class="sd">Contains the main Geoimage class and utility functions for raster processing.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="c1"># Google Colab detection and setup</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">google.colab</span>
    <span class="n">IN_COLAB</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">IN_COLAB</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">google.colab</span><span class="w"> </span><span class="kn">import</span> <span class="n">output</span>
        <span class="n">output</span><span class="o">.</span><span class="n">enable_custom_widget_manager</span><span class="p">()</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">google.colab</span><span class="w"> </span><span class="kn">import</span> <span class="n">drive</span>
        <span class="n">drive</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s1">&#39;/content/drive&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;pip install rasterio&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;pip install ipympl&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">IN_COLAB</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">end_collect</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Flag used for collecting spectra</span>

<span class="c1"># Standard library imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>

<span class="c1"># Scientific and numerical libraries</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">MinMaxScaler</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.backends.backend_webagg_core</span><span class="w"> </span><span class="kn">import</span> <span class="n">NavigationToolbar2WebAgg</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span>

<span class="c1"># Rasterio and geospatial imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rasterio</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">rio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio</span><span class="w"> </span><span class="kn">import</span> <span class="n">windows</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.warp</span><span class="w"> </span><span class="kn">import</span> <span class="n">reproject</span><span class="p">,</span> <span class="n">Resampling</span><span class="p">,</span> <span class="n">calculate_default_transform</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Affine</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.plot</span><span class="w"> </span><span class="kn">import</span> <span class="n">show_hist</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.features</span><span class="w"> </span><span class="kn">import</span> <span class="n">rasterize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_bounds</span>

<span class="c1"># Geopandas for vector operations</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>

<span class="c1"># Local imports with relative path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Configure warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
<span class="c1"># Configure matplotlib backend based on environment</span>
<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;DISPLAY&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
    <span class="c1"># Use &#39;agg&#39; if no GUI is detected</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;agg&#39;</span><span class="p">)</span>
<span class="c1">#else:</span>
    <span class="c1"># Use &#39;tkagg&#39; for standard interactive display (commented out in original)</span>
<span class="c1">#    matplotlib.use(&#39;tkagg&#39;)</span>

<span class="c1"># Default constants</span>
<span class="n">DEF_FIG_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Default figure size for visualizations</span>
<span class="n">RANDOM_STATE</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># Random state for reproducible results</span>


<span class="k">def</span><span class="w"> </span><span class="nf">read_geoim</span><span class="p">(</span><span class="n">source_name</span><span class="p">,</span> <span class="n">read_image</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a geotiff image file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_name : str</span>
<span class="sd">        Path to the geotiff image file</span>
<span class="sd">    read_image : bool, optional</span>
<span class="sd">        If True, read both image data and metadata. If False, read only metadata.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    channel_first : bool, optional</span>
<span class="sd">        If True, return image with shape (bands, rows, cols).</span>
<span class="sd">        If False, return image with shape (rows, cols, bands).</span>
<span class="sd">        Only relevant when read_image is True.</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray or None</span>
<span class="sd">        Image data if read_image is True, None otherwise</span>
<span class="sd">    dict</span>
<span class="sd">        Metadata dictionary from rasterio</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Read image data and metadata</span>
<span class="sd">    &gt;&gt;&gt; image, meta = read_geoim(&quot;path/to/image.tif&quot;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Read only metadata</span>
<span class="sd">    &gt;&gt;&gt; meta = read_geoim(&quot;path/to/image.tif&quot;, read_image=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">source_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">read_image</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">channel_first</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span>


<span class="k">def</span><span class="w"> </span><span class="nf">write_geoim</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">meta_input</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write a geotiff image to disk.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : numpy.ndarray</span>
<span class="sd">        Image data to write</span>
<span class="sd">    meta_input : dict</span>
<span class="sd">        Metadata dictionary with rasterio metadata fields</span>
<span class="sd">    dest_name : str</span>
<span class="sd">        Output path for the geotiff file</span>
<span class="sd">    channel_first : bool, optional</span>
<span class="sd">        If True, assumes image has shape (bands, rows, cols).</span>
<span class="sd">        If False, assumes image has shape (rows, cols, bands).</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; write_geoim(image, metadata, &quot;output.tif&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="n">meta_input</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Create output directory if it doesn&#39;t exist</span>
    <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">folder</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>

    <span class="c1"># Remove existing file to avoid conflicts</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_name</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">)</span>

    <span class="c1"># Set driver based on file extension</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.tif&#39;</span><span class="p">:</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;GTiff&#39;</span>
    <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.jp2&#39;</span><span class="p">:</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;JP2OpenJPEG&#39;</span>

    <span class="c1"># Handle boolean data type</span>
    <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">rio</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># Write the image</span>
    <span class="k">if</span> <span class="n">channel_first</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dest_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dest_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">diff_im</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the L1 norm (sum of absolute differences) between two Geoimages.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im1 : Geoimage</span>
<span class="sd">        First image</span>
<span class="sd">    im2 : Geoimage</span>
<span class="sd">        Second image</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        L1 norm of the difference between the images</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im1</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">im2</span><span class="o">.</span><span class="n">image</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">im2tiles_sequence</span><span class="p">(</span><span class="n">source_name</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">,</span> <span class="n">nb_row</span><span class="p">,</span> <span class="n">nb_col</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">type_name</span><span class="o">=</span><span class="s1">&#39;sequence&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split a sequence of GeoTIFF images into tiles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_name : str</span>
<span class="sd">        Directory containing the GeoTIFF images.</span>
<span class="sd">    dest_name : str</span>
<span class="sd">        Destination directory for tiled images.</span>
<span class="sd">    nb_row : int</span>
<span class="sd">        Number of rows in each tiled image.</span>
<span class="sd">    nb_col : int</span>
<span class="sd">        Number of columns in each tiled image.</span>
<span class="sd">    overlap : int, optional</span>
<span class="sd">        Overlap between tiles in pixels. Default is 0.</span>
<span class="sd">    type_name : str, optional</span>
<span class="sd">        Naming convention for output tiles:</span>
<span class="sd">        - &quot;sequence&quot;: Outputs as name_tif_001.tif, name_tif_002.tif, etc.</span>
<span class="sd">        - &quot;coord&quot;: Outputs as name_tif_tiles_{row}-{col}.tif.</span>
<span class="sd">        Default is &quot;sequence&quot;.</span>
<span class="sd">    verbose : int, optional</span>
<span class="sd">        If 1, prints information about processed images. Default is 0.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If type_name is not &quot;sequence&quot; or &quot;coord&quot;.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; im2tiles_sequence(</span>
<span class="sd">    &gt;&gt;&gt;      source_name=&quot;/path/to/source&quot;,</span>
<span class="sd">    &gt;&gt;&gt;      dest_name=&quot;/path/to/destination&quot;,</span>
<span class="sd">    &gt;&gt;&gt;      nb_row=256,</span>
<span class="sd">    &gt;&gt;&gt;      nb_col=256,</span>
<span class="sd">    &gt;&gt;&gt;      overlap=10,</span>
<span class="sd">    &gt;&gt;&gt;      type_name=&quot;sequence&quot;,</span>
<span class="sd">    &gt;&gt;&gt;      verbose=1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">type_name</span> <span class="o">==</span> <span class="s2">&quot;sequence&quot;</span> <span class="ow">or</span> <span class="n">type_name</span> <span class="o">==</span> <span class="s2">&quot;coord&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;type_name must be either sequence or coord&quot;</span><span class="p">)</span>

    <span class="c1"># Get list of all tif files in the source directory</span>
    <span class="n">list_im</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">source_name</span><span class="si">}</span><span class="s1">/*tif&#39;</span><span class="p">)</span>

    <span class="c1"># Create destination directory if it doesn&#39;t exist</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_name</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;creation of folder &#39;</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span>

    <span class="c1"># Process each image</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_im</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;process </span><span class="si">{</span><span class="n">list_im</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">split_image_to_tiles</span><span class="p">(</span>
            <span class="n">list_im</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">dest_name</span><span class="p">,</span>
            <span class="n">nb_col</span><span class="p">,</span>
            <span class="n">nb_row</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">type_name</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">name_tile</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">im2tiles</span><span class="p">(</span><span class="n">source_name</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">,</span> <span class="n">nb_row</span><span class="p">,</span> <span class="n">nb_col</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">type_name</span><span class="o">=</span><span class="s1">&#39;sequence&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name_tile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split a geotif image into tiles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_name : str</span>
<span class="sd">        A tif file to be split.</span>
<span class="sd">    dest_name : str</span>
<span class="sd">        Destination directory for tiled images.</span>
<span class="sd">    nb_row : int</span>
<span class="sd">        Number of rows in each tiled image.</span>
<span class="sd">    nb_col : int</span>
<span class="sd">        Number of columns in each tiled image.</span>
<span class="sd">    overlap : int, optional</span>
<span class="sd">        Overlap between tiles in pixels. Default is 0.</span>
<span class="sd">    type_name : str, optional</span>
<span class="sd">        Naming convention for output tiles. Either &quot;sequence&quot; or &quot;coord&quot;.</span>
<span class="sd">        Default is &quot;sequence&quot;.</span>
<span class="sd">    verbose : int, optional</span>
<span class="sd">        If 1, prints information about processed images. Default is 0.</span>
<span class="sd">    name_tile : str, optional</span>
<span class="sd">        Generic name for output tiles. If None, uses source_name without extension.</span>
<span class="sd">        Default is None.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If type_name is not &quot;sequence&quot; or &quot;coord&quot;.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; im2tiles(</span>
<span class="sd">    &gt;&gt;&gt;      source_name=&quot;input.tif&quot;,</span>
<span class="sd">    &gt;&gt;&gt;      dest_name=&quot;/path/to/destination&quot;,</span>
<span class="sd">    &gt;&gt;&gt;      nb_row=256,</span>
<span class="sd">    &gt;&gt;&gt;      nb_col=256,</span>
<span class="sd">    &gt;&gt;&gt;      overlap=10,</span>
<span class="sd">    &gt;&gt;&gt;      type_name=&quot;sequence&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">type_name</span> <span class="o">==</span> <span class="s2">&quot;sequence&quot;</span> <span class="ow">or</span> <span class="n">type_name</span> <span class="o">==</span> <span class="s2">&quot;coord&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;type_name must be either sequence or coord&quot;</span><span class="p">)</span>

    <span class="c1"># Create destination directory if it doesn&#39;t exist</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_name</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;creation of folder &#39;</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span>

    <span class="c1"># Process the image</span>
    <span class="n">split_image_to_tiles</span><span class="p">(</span>
        <span class="n">source_name</span><span class="p">,</span>
        <span class="n">dest_name</span><span class="p">,</span>
        <span class="n">nb_col</span><span class="p">,</span>
        <span class="n">nb_row</span><span class="p">,</span>
        <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">type_name</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">name_tile</span><span class="o">=</span><span class="n">name_tile</span>
    <span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">crop_rio</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">deb_row</span><span class="p">,</span> <span class="n">end_row</span><span class="p">,</span> <span class="n">deb_col</span><span class="p">,</span> <span class="n">end_col</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop a georeferenced image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : str or numpy.ndarray</span>
<span class="sd">        Path to a GeoTIFF image or a numpy array containing image data.</span>
<span class="sd">        If a numpy array is provided, meta must also be provided.</span>
<span class="sd">    deb_row : int</span>
<span class="sd">        Starting row coordinate (pixel).</span>
<span class="sd">    end_row : int</span>
<span class="sd">        Ending row coordinate (pixel).</span>
<span class="sd">    deb_col : int</span>
<span class="sd">        Starting column coordinate (pixel).</span>
<span class="sd">    end_col : int</span>
<span class="sd">        Ending column coordinate (pixel).</span>
<span class="sd">    dest_name : str, optional</span>
<span class="sd">        Path to save the cropped image. If None, the image is not saved.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    meta : dict, optional</span>
<span class="sd">        Metadata dictionary (required if data is a numpy array).</span>
<span class="sd">        Default is None.</span>
<span class="sd">    channel_first : bool, optional</span>
<span class="sd">        If True, assumes/returns image with shape (bands, rows, cols).</span>
<span class="sd">        If False, assumes/returns image with shape (rows, cols, bands).</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Cropped image data</span>
<span class="sd">    dict</span>
<span class="sd">        Updated metadata</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If data is a numpy array but meta is not provided.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Crop from a file</span>
<span class="sd">    &gt;&gt;&gt; im, meta = crop_rio(&quot;input.tif&quot;, 100, 500, 200, 600, &quot;cropped.tif&quot;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Crop from a numpy array</span>
<span class="sd">    &gt;&gt;&gt; im, meta = crop_rio(image_array, 100, 500, 200, 600, meta=metadata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Case 1: data is a file path</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">Window</span><span class="o">.</span><span class="n">from_slices</span><span class="p">((</span><span class="n">deb_row</span><span class="p">,</span> <span class="n">end_row</span><span class="p">),</span> <span class="p">(</span><span class="n">deb_col</span><span class="p">,</span> <span class="n">end_col</span><span class="p">))</span>
        <span class="n">big_window</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">Window</span><span class="p">(</span><span class="n">col_off</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">row_off</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">],</span> <span class="n">height</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">])</span>
        <span class="n">wind</span> <span class="o">=</span> <span class="n">win</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">big_window</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">wind</span><span class="p">,</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;GTiff&#39;</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">win</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">channel_first</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">elif</span> <span class="p">(</span><span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="c1"># Case 2: data is a numpy array but no metadata provided</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to provide metadata with input data&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Case 3: data is a numpy array with metadata</span>
        <span class="k">if</span> <span class="n">channel_first</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">deb_row</span><span class="p">:</span><span class="n">end_row</span><span class="p">,</span> <span class="n">deb_col</span><span class="p">:</span><span class="n">end_col</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">deb_row</span><span class="p">:</span><span class="n">end_row</span><span class="p">,</span> <span class="n">deb_col</span><span class="p">:</span><span class="n">end_col</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Update metadata</span>
        <span class="n">new_meta</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_row</span> <span class="o">-</span> <span class="n">deb_row</span>
        <span class="n">new_meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_col</span> <span class="o">-</span> <span class="n">deb_col</span>

        <span class="c1"># Calculate new transform</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span>
        <span class="n">new_transform</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="n">Affine</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="n">deb_col</span><span class="p">,</span> <span class="n">deb_row</span><span class="p">)</span>

        <span class="c1"># Update transform in metadata</span>
        <span class="n">new_meta</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_transform</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">new_meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need either to provide metadata with input numpy array or a path to a geotif image&quot;</span><span class="p">)</span>

    <span class="c1"># Save cropped image if destination name is provided</span>
    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">folder</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_name</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">channel_first</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dest_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">outds</span><span class="p">:</span>
                <span class="n">outds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dest_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">outds</span><span class="p">:</span>
                <span class="n">outds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">im</span><span class="p">,</span> <span class="n">meta</span>


<span class="k">def</span><span class="w"> </span><span class="nf">crop_rio_sequence</span><span class="p">(</span><span class="n">source_name</span><span class="p">,</span> <span class="n">deb_row</span><span class="p">,</span> <span class="n">end_row</span><span class="p">,</span> <span class="n">deb_col</span><span class="p">,</span> <span class="n">end_col</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop a sequence of georeferenced images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_name : str</span>
<span class="sd">        Path to the directory containing GeoTIFF images.</span>
<span class="sd">    deb_row : int</span>
<span class="sd">        Starting row coordinate (pixel).</span>
<span class="sd">    end_row : int</span>
<span class="sd">        Ending row coordinate (pixel).</span>
<span class="sd">    deb_col : int</span>
<span class="sd">        Starting column coordinate (pixel).</span>
<span class="sd">    end_col : int</span>
<span class="sd">        Ending column coordinate (pixel).</span>
<span class="sd">    dest_name : str, optional</span>
<span class="sd">        Path to save the cropped images. If None, images are not saved.</span>
<span class="sd">        Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of numpy.ndarray</span>
<span class="sd">        List of cropped images</span>
<span class="sd">    list of dict</span>
<span class="sd">        List of updated metadata</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; images, metadatas = crop_rio_sequence(&quot;input_dir&quot;, 100, 500, 200, 600, &quot;output_dir&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get list of all tif files in the source directory</span>
    <span class="n">list_im</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">source_name</span><span class="si">}</span><span class="s1">/*tif&#39;</span><span class="p">)</span>
    <span class="n">im_cropped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meta_cropped</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Create output directory if needed</span>
    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_name</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;creation of folder &#39;</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span>

    <span class="c1"># Process each image</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_im</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_out</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">list_im</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_out</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">im</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">crop_rio</span><span class="p">(</span><span class="n">list_im</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">deb_row</span><span class="p">,</span> <span class="n">end_row</span><span class="p">,</span> <span class="n">deb_col</span><span class="p">,</span> <span class="n">end_col</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">name_out</span><span class="p">)</span>
        <span class="n">im_cropped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="n">meta_cropped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">im_cropped</span><span class="p">,</span> <span class="n">meta_cropped</span>


<span class="k">def</span><span class="w"> </span><span class="nf">resampling</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">final_resolution</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cubic_spline&#39;</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample a georeferenced image to a new resolution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : str or numpy.ndarray</span>
<span class="sd">        The name of the input TIFF image or a numpy array with shape (N, row, col).</span>
<span class="sd">        If a numpy array is provided, an associated `meta` is required.</span>
<span class="sd">    final_resolution : float</span>
<span class="sd">        The desired resolution of the output image (in meters or degrees).</span>
<span class="sd">    dest_name : str, optional</span>
<span class="sd">        The name of the resampled image file to save. If None, the image is not saved.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        The resampling method to use.</span>
<span class="sd">        Available methods: &#39;cubic_spline&#39; (default), &#39;nearest&#39;, &#39;bilinear&#39;, &#39;cubic&#39;,</span>
<span class="sd">                          &#39;lanczos&#39;, &#39;average&#39;, &#39;mode&#39;, &#39;max&#39;, &#39;min&#39;, &#39;med&#39;, &#39;sum&#39;,</span>
<span class="sd">                          &#39;q1&#39;, &#39;q3&#39;.</span>
<span class="sd">        Default is &#39;cubic_spline&#39;.</span>
<span class="sd">    channel_first : bool, optional</span>
<span class="sd">        Whether to output the image in a shape of (bands, rows, cols).</span>
<span class="sd">        If False, the output shape will be (rows, cols, bands).</span>
<span class="sd">        Default is True.</span>
<span class="sd">    meta : dict, optional</span>
<span class="sd">        Metadata to use if `data` is a numpy array.</span>
<span class="sd">        Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The resampled image.</span>
<span class="sd">    dict</span>
<span class="sd">        The metadata associated with the resampled image.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Resample a GeoTIFF image to a new resolution</span>
<span class="sd">    &gt;&gt;&gt; resampled_image, meta = resampling(&#39;image.tif&#39;, 10)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Resample a numpy array with custom metadata</span>
<span class="sd">    &gt;&gt;&gt; data = np.random.rand(4, 100, 100)  # Example data</span>
<span class="sd">    &gt;&gt;&gt; meta = {&#39;driver&#39;: &#39;GTiff&#39;, &#39;count&#39;: 4, &#39;dtype&#39;: &#39;float32&#39;, &#39;width&#39;: 100, &#39;height&#39;: 100}</span>
<span class="sd">    &gt;&gt;&gt; resampled_image, meta = resampling(data, 10, meta=meta)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">resample_image_with_resolution</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">final_resolution</span><span class="p">,</span>
            <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">channel_first</span><span class="o">=</span><span class="n">channel_first</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to provide metadata with input data&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">resampling_image</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">meta</span><span class="p">,</span>
            <span class="n">final_resolution</span><span class="p">,</span>
            <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">channel_first</span><span class="o">=</span><span class="n">channel_first</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">np2rio</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a numpy array in channel-last format to channel-first format for rasterio.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : numpy.ndarray</span>
<span class="sd">        Input image in channel-last format (rows, cols, bands).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Image in channel-first format (bands, rows, cols).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; rio_image = np2rio(numpy_image)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">rio2np</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a rasterio image in channel-first format to channel-last format for numpy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : numpy.ndarray</span>
<span class="sd">        Input image in channel-first format (bands, rows, cols).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Image in channel-last format (rows, cols, bands).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; numpy_image = rio2np(rio_image)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">image2table</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reshape an image into a 2D table of size (rows*cols, bands).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : numpy.ndarray</span>
<span class="sd">        Input image array.</span>
<span class="sd">    channel_first : bool, optional</span>
<span class="sd">        If True, assumes input has shape (bands, rows, cols).</span>
<span class="sd">        If False, assumes input has shape (rows, cols, bands).</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        A 2D array of shape (rows*cols, bands).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; table = image2table(image, channel_first=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">channel_first</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span>
        <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">table2image</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reshape a 2D table back into a 3D image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    table : numpy.ndarray</span>
<span class="sd">        Input table with shape (rows*cols, bands) or (rows*cols,).</span>
<span class="sd">    size : tuple</span>
<span class="sd">        Size of the output image as (rows, cols).</span>
<span class="sd">    channel_first : bool, optional</span>
<span class="sd">        If True, output will have shape (bands, rows, cols).</span>
<span class="sd">        If False, output will have shape (rows, cols, bands).</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Reshaped 3D image.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; image = table2image(table, (400, 600), channel_first=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">channel_first</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">table</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">channel_first</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">bands</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bands</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bands</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bands</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span>

<span class="k">def</span><span class="w"> </span><span class="nf">shp2geoim2</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;code&#39;</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convertit un shapefile en donnes raster et mtadonnes gospatiales.</span>

<span class="sd">    Cette fonction transforme des donnes vectorielles d&#39;un shapefile en une matrice</span>
<span class="sd">    raster et gnre les mtadonnes appropries pour le gorfrencement.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shapefile_path : str</span>
<span class="sd">        Chemin d&#39;accs au fichier shapefile (.shp).</span>
<span class="sd">    attribute : str, optional</span>
<span class="sd">        Attribut du shapefile  utiliser pour les valeurs des pixels dans le raster.</span>
<span class="sd">        Default is &#39;code&#39;.</span>
<span class="sd">    resolution : float, optional</span>
<span class="sd">        Rsolution spatiale (taille des pixels) du raster de sortie en units</span>
<span class="sd">        du systme de coordonnes (gnralement mtres ou degrs).</span>
<span class="sd">        Default is 10.</span>
<span class="sd">    nodata : int or float, optional</span>
<span class="sd">        Valeur  attribuer aux zones situes en dehors des formes du shapefile.</span>
<span class="sd">        Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        Un tuple contenant:</span>
<span class="sd">        - data (numpy.ndarray): Tableau 2D contenant les donnes rasterises</span>
<span class="sd">        - meta (dict): Dictionnaire de mtadonnes avec les informations de gorfrencement</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Si le shapefile n&#39;a pas de systme de coordonnes (CRS) dfini</span>
<span class="sd">        Si l&#39;attribut spcifi n&#39;existe pas dans le shapefile</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; data, meta = shp2geoim2(&quot;landcover.shp&quot;, attribute=&quot;landtype&quot;, resolution=30)</span>
<span class="sd">    &gt;&gt;&gt; im = Geoimage(data=data, meta=meta)</span>
<span class="sd">    &gt;&gt;&gt; im.info()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.features</span><span class="w"> </span><span class="kn">import</span> <span class="n">rasterize</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_bounds</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.enums</span><span class="w"> </span><span class="kn">import</span> <span class="n">MergeAlg</span>

    <span class="c1"># Charger le shapefile</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>

    <span class="c1"># Vrifier le CRS</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The shapefile </span><span class="si">{</span><span class="n">shapefile_path</span><span class="si">}</span><span class="s2"> does not have a defined CRS.&quot;</span><span class="p">)</span>

    <span class="c1"># Vrifier l&#39;attribut</span>
    <span class="k">if</span> <span class="n">attribute</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">available_attrs</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">&#39; not found in shapefile &#39;</span><span class="si">{</span><span class="n">shapefile_path</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Available attributes are: </span><span class="si">{</span><span class="n">available_attrs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Calculer les limites (sans arrondi)</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

    <span class="c1"># Crer les formes pour la rasterisation</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="p">((</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf</span><span class="p">[</span><span class="n">attribute</span><span class="p">]))</span>

    <span class="c1"># Rasterisation avec gestion d&#39;erreurs</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">rasterize</span><span class="p">(</span>
            <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
            <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">nodata</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span>
            <span class="n">merge_alg</span><span class="o">=</span><span class="n">MergeAlg</span><span class="o">.</span><span class="n">replace</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during rasterization: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Mtadonnes</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="s1">&#39;GTiff&#39;</span><span class="p">,</span>
        <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span>
        <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
        <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">nodata</span><span class="p">,</span>
        <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
        <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
        <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">meta</span>


<div class="viewcode-block" id="shpfiles">
<a class="viewcode-back" href="../../modules.html#rastereasy.shpfiles">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">shpfiles</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility class for working with shapefiles and converting them to raster formats.</span>

<span class="sd">    This class contains static methods for operations like:</span>
<span class="sd">    - Getting attribute names from shapefiles</span>
<span class="sd">    - Converting shapefiles to raster data</span>
<span class="sd">    - Converting shapefiles directly to Geoimage objects</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Get attributes from a shapefile</span>
<span class="sd">    &gt;&gt;&gt; attributes = shpfiles.get_shapefile_attributes(&quot;landcover.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Convert a shapefile to a raster file</span>
<span class="sd">    &gt;&gt;&gt; shpfiles.shp2raster(&quot;landcover.shp&quot;, &quot;landcover.tif&quot;, attribute=&quot;landtype&quot;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Convert a shapefile to a Geoimage object</span>
<span class="sd">    &gt;&gt;&gt; landcover_img = shpfiles.shp2geoim(&quot;landcover.shp&quot;, attribute=&quot;landtype&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="shpfiles.get_shapefile_attributes">
<a class="viewcode-back" href="../../modules.html#rastereasy.shpfiles.get_shapefile_attributes">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_shapefile_attributes</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the attribute field names from a shapefile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapefile_path : str</span>
<span class="sd">            Path to the input shapefile.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of attribute field names in the shapefile.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; attributes = shpfiles.get_shapefile_attributes(&quot;landcover.shp&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(attributes)</span>
<span class="sd">        &gt;&gt;&gt; [&#39;FID&#39;, &#39;landtype&#39;, &#39;area&#39;, &#39;perimeter&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Load the shapefile using geopandas</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>

            <span class="c1"># Get the column names</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">attributes</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading shapefile: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__shp2geoim2</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;code&#39;</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a shapefile to a Geoimage object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapefile_path : str</span>
<span class="sd">            Path to the input shapefile.</span>
<span class="sd">        attribute : str, optional</span>
<span class="sd">            Attribute field in the shapefile to assign values to each pixel.</span>
<span class="sd">            Default is &#39;code&#39;.</span>
<span class="sd">        resolution : float, optional</span>
<span class="sd">            Spatial resolution of the output raster in meters (or degrees).</span>
<span class="sd">            Default is 10.</span>
<span class="sd">        nodata : int or float, optional</span>
<span class="sd">            Value to assign to areas outside the shapes.</span>
<span class="sd">            Default is 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A Geoimage object containing the rasterized data.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the shapefile does not have a defined CRS</span>
<span class="sd">            If the specified attribute is not found in the shapefile</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; landcover_img = shpfiles.shp2geoim2(&quot;landcover.shp&quot;, attribute=&quot;landtype&quot;)</span>
<span class="sd">        &gt;&gt;&gt; landcover_img.visu()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.features</span><span class="w"> </span><span class="kn">import</span> <span class="n">rasterize</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_bounds</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.enums</span><span class="w"> </span><span class="kn">import</span> <span class="n">MergeAlg</span>

        <span class="c1"># Load the shapefile</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>

        <span class="c1"># Check if CRS is defined</span>
        <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The shapefile </span><span class="si">{</span><span class="n">shapefile_path</span><span class="si">}</span><span class="s2"> does not have a defined CRS.&quot;</span><span class="p">)</span>

        <span class="c1"># Check if attribute exists</span>
        <span class="k">if</span> <span class="n">attribute</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">&#39; not found in shapefile &#39;</span><span class="si">{</span><span class="n">shapefile_path</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate bounds (without rounding)</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

        <span class="c1"># Create shapes for rasterization</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">((</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf</span><span class="p">[</span><span class="n">attribute</span><span class="p">]))</span>

        <span class="c1"># Rasterize</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">rasterize</span><span class="p">(</span>
            <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
            <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">nodata</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span>
            <span class="n">merge_alg</span><span class="o">=</span><span class="n">MergeAlg</span><span class="o">.</span><span class="n">replace</span>
        <span class="p">)</span>

        <span class="c1"># Create metadata</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="s1">&#39;GTiff&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span>
            <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
            <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">nodata</span><span class="p">,</span>
            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
            <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span>

<div class="viewcode-block" id="shpfiles.shp2geoim">
<a class="viewcode-back" href="../../modules.html#rastereasy.shpfiles.shp2geoim">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shp2geoim</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;code&#39;</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a shapefile to a Geoimage object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapefile_path : str</span>
<span class="sd">            Path to the input shapefile.</span>
<span class="sd">        attribute : str, optional</span>
<span class="sd">            Attribute field in the shapefile to assign values to each pixel.</span>
<span class="sd">            Default is &#39;code&#39;.</span>
<span class="sd">        resolution : float, optional</span>
<span class="sd">            Spatial resolution of the output raster in meters/degrees.</span>
<span class="sd">            Default is 10.</span>
<span class="sd">        nodata : int or float, optional</span>
<span class="sd">            Value to assign to areas outside the shapes.</span>
<span class="sd">            Default is 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A Geoimage object containing the rasterized data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The `shapefile_path` should be the full path to a shapefile (.shp) on the disk.</span>
<span class="sd">        - The `attribute` field will be assigned to each pixel in the rasterized Geoimage.</span>
<span class="sd">        - To get the attributes of a shapefile, see :meth:`shpfiles.get_shapefile_attributes`</span>
<span class="sd">        - The `resolution` sets the size of each pixel in the output image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geo_img = shpfiles.shp2geoim(&quot;landcover.shp&quot;, attribute=&#39;landtype&#39;, resolution=5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attribute</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">shpfiles</span><span class="o">.</span><span class="n">get_shapefile_attributes</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Attributes of shapefile&#39;</span><span class="p">,</span> <span class="n">shapefile_path</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">shpfiles</span><span class="o">.</span><span class="n">get_shapefile_attributes</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attribute </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s1"> not in attributes of shapefile </span><span class="si">{</span><span class="n">shapefile_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>

        <span class="c1"># Check if CRS is defined</span>
        <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The shapefile </span><span class="si">{</span><span class="n">shapefile_path</span><span class="si">}</span><span class="s2"> does not have a defined CRS.&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate bounds of the shapefile</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>

        <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>

        <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

        <span class="n">shapes</span> <span class="o">=</span> <span class="p">((</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf</span><span class="p">[</span><span class="n">attribute</span><span class="p">]))</span>

        <span class="n">raster</span> <span class="o">=</span> <span class="n">rasterize</span><span class="p">(</span>
            <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
            <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">nodata</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>

        <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="s1">&#39;GTiff&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span>
            <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
            <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">nodata</span><span class="p">,</span>
            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
            <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">raster</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">)</span></div>


<div class="viewcode-block" id="shpfiles.shp2raster">
<a class="viewcode-back" href="../../modules.html#rastereasy.shpfiles.shp2raster">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shp2raster</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;code&#39;</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a shapefile to a GeoTIFF raster file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapefile_path : str</span>
<span class="sd">            Path to the input shapefile.</span>
<span class="sd">        dest_name : str</span>
<span class="sd">            Path to save the output raster file.</span>
<span class="sd">        attribute : str, optional</span>
<span class="sd">            Attribute field in the shapefile to assign values to each pixel.</span>
<span class="sd">            Default is &#39;code&#39;.</span>
<span class="sd">        resolution : float, optional</span>
<span class="sd">            Spatial resolution of the output raster in meters/degrees.</span>
<span class="sd">            Default is 10.</span>
<span class="sd">        nodata : int or float, optional</span>
<span class="sd">            Value to assign to areas outside the shapes.</span>
<span class="sd">            Default is 0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The `shapefile_path` should be the full path to a shapefile (.shp) on the disk.</span>
<span class="sd">        - To get the attributes of a shapefile, see :meth:`shpfiles.get_shapefile_attributes`</span>
<span class="sd">        - The output raster will be written in GeoTIFF format to the path specified by `dest_name`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; shpfiles.shp2raster(&quot;landcover.shp&quot;, &quot;landcover.tif&quot;, attribute=&#39;landtype&#39;, resolution=5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>

        <span class="c1"># Calculate bounds of the shapefile</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">total_bounds</span>

        <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span>

        <span class="n">transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

        <span class="n">shapes</span> <span class="o">=</span> <span class="p">((</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gdf</span><span class="p">[</span><span class="n">attribute</span><span class="p">]))</span>

        <span class="n">raster</span> <span class="o">=</span> <span class="n">rasterize</span><span class="p">(</span>
            <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
            <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">nodata</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>

        <span class="c1"># Save the raster as GeoTIFF</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="ow">and</span> <span class="n">folder</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_name</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">dest_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span>
            <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;GTiff&#39;</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">nodata</span><span class="o">=</span><span class="n">nodata</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="rasters">
<a class="viewcode-back" href="../../modules.html#rastereasy.rasters">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">rasters</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility class for raster image operations.</span>

<span class="sd">    This class provides static methods for operations like stacking multiple images</span>
<span class="sd">    and removing bands from images.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Stack two images</span>
<span class="sd">    &gt;&gt;&gt; combined_image = rasters.stack(image1, image2)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Remove bands from an image</span>
<span class="sd">    &gt;&gt;&gt; reduced_image = rasters.remove_bands(image, bands=[&quot;NIR&quot;, &quot;SWIR1&quot;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="rasters.stack">
<a class="viewcode-back" href="../../modules.html#rastereasy.rasters.stack">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">stack</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stack two Geoimage objects into a single image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        im1 : Geoimage</span>
<span class="sd">            First image to stack</span>
<span class="sd">        im2 : Geoimage</span>
<span class="sd">            Second image to stack</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            Data type for the output image.</span>
<span class="sd">            Default is &#39;float64&#39;.</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the stacked image.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        reformat_names : bool, optional</span>
<span class="sd">            How to handle band names:</span>
<span class="sd">            - If True: Reset all names like {&quot;1&quot;:1, &quot;2&quot;:2, ...}</span>
<span class="sd">            - If False: Adapt names like {&quot;NIR_1&quot;:1, &quot;R_1&quot;:2, &quot;G_1&quot;:3, &quot;R_2&quot;:4, ...}</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage containing all bands from both input images</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; combined = rasters.stack(sentinel2_img, landsat8_img)</span>
<span class="sd">        &gt;&gt;&gt; combined.info()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">im1</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="n">reformat_names</span><span class="p">)</span></div>


<div class="viewcode-block" id="rasters.remove_bands">
<a class="viewcode-back" href="../../modules.html#rastereasy.rasters.remove_bands">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_bands</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove specified bands from an image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        im : Geoimage</span>
<span class="sd">            The input image</span>
<span class="sd">        bands : str, list, or numpy.ndarray</span>
<span class="sd">            The bands to remove, specified as either:</span>
<span class="sd">            - A string with a band name (e.g., &#39;SWIR1&#39;)</span>
<span class="sd">            - A list or array of band names (e.g., [&#39;R&#39;, &#39;G&#39;, &#39;B&#39;])</span>
<span class="sd">            - An integer representing the band index (e.g., 4)</span>
<span class="sd">            - A list or array of band indices (e.g., [4, 2, 3])</span>
<span class="sd">        reformat_names : bool, optional</span>
<span class="sd">            If True, the band names are renumbered from 1 after removal.</span>
<span class="sd">            If False, the original band names are preserved (gaps may remain).</span>
<span class="sd">            Default is True.</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the modified image.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with the specified bands removed</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; reduced_img = rasters.remove_bands(image, bands=[&quot;NIR&quot;, &quot;SWIR1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; reduced_img.info()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">im</span><span class="o">.</span><span class="n">remove_bands</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="n">reformat_names</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Visualizer">
<a class="viewcode-back" href="../../modules.html#rastereasy.Visualizer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Visualizer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility class for visualizing raster image data.</span>

<span class="sd">    This class provides methods for interactive plotting and exploration of</span>
<span class="sd">    spectral data in georeferenced images.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Extract and plot spectral values from user-selected pixels</span>
<span class="sd">    &gt;&gt;&gt; series, pixel_i, pixel_j = Visualizer.plot_spectra(image, bands=[&#39;R&#39;, &#39;G&#39;, &#39;B&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Visualizer.plot_spectra">
<a class="viewcode-back" href="../../modules.html#rastereasy.Visualizer.plot_spectra">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_spectra</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fig_size</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                     <span class="n">title_im</span><span class="o">=</span><span class="s2">&quot;Original image (click outside to stop)&quot;</span><span class="p">,</span>
                     <span class="n">title_spectra</span><span class="o">=</span><span class="s2">&quot;Spectra&quot;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Bands&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Value&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots and extracts spectral values from user-selected pixels on a multispectral image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        im : Geoimage</span>
<span class="sd">            Multispectral georeferenced image to analyze.</span>
<span class="sd">        bands : list, optional</span>
<span class="sd">            List of bands to use for the color composition in the image plot.</span>
<span class="sd">            Default is None (uses the first three bands).</span>
<span class="sd">        fig_size : tuple, optional</span>
<span class="sd">            Size of the figure in inches, specified as (width, height).</span>
<span class="sd">            Default is (15, 5).</span>
<span class="sd">        percentile : int, optional</span>
<span class="sd">            Percentile value for the color composition scaling.</span>
<span class="sd">            Default is 2.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Main title for the figure.</span>
<span class="sd">            Default is &#39;&#39;.</span>
<span class="sd">        title_im : str, optional</span>
<span class="sd">            Title for the image plot.</span>
<span class="sd">            Default is &quot;Original image (click outside to stop)&quot;.</span>
<span class="sd">        title_spectra : str, optional</span>
<span class="sd">            Title for the spectra curves plot.</span>
<span class="sd">            Default is &quot;Spectra&quot;.</span>
<span class="sd">        xlabel : str, optional</span>
<span class="sd">            X-axis label for the spectra curves plot.</span>
<span class="sd">            Default is &quot;Bands&quot;.</span>
<span class="sd">        ylabel : str, optional</span>
<span class="sd">            Y-axis label for the spectra curves plot.</span>
<span class="sd">            Default is &quot;Value&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of lists</span>
<span class="sd">            Collection of spectral series extracted from the selected pixels.</span>
<span class="sd">        list of int</span>
<span class="sd">            List of row indices (i-coordinates) of the selected pixels.</span>
<span class="sd">        list of int</span>
<span class="sd">            List of column indices (j-coordinates) of the selected pixels.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The data collection stops when the user clicks outside the image area or</span>
<span class="sd">        clicks the &quot;Finish&quot; button.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; series, i_coords, j_coords = Visualizer.plot_spectra(</span>
<span class="sd">        &gt;&gt;&gt;      image, bands=[&#39;B01&#39;, &#39;B02&#39;, &#39;B03&#39;], fig_size=(10, 5))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">imc</span> <span class="o">=</span> <span class="n">extract_colorcomp</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="n">bands</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">on_finish</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">val_i</span><span class="p">,</span> <span class="n">val_j</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Acquisition finished !&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Collected Spectra : </span><span class="si">{</span><span class="n">series</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rows : </span><span class="si">{</span><span class="n">val_i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cols : </span><span class="si">{</span><span class="n">val_j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">on_end_collect</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">val_i</span><span class="p">,</span> <span class="n">val_j</span><span class="p">):</span>
            <span class="c1"># Code to be executed after the user finishes selecting pixels</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;User has finished selecting pixels.&quot;</span><span class="p">)</span>

        <span class="n">series</span><span class="p">,</span> <span class="n">val_i</span><span class="p">,</span> <span class="n">val_j</span><span class="p">,</span> <span class="n">end_collect</span> <span class="o">=</span> <span class="n">plot_clic_spectra</span><span class="p">(</span>
            <span class="n">im</span><span class="o">.</span><span class="n">numpy_channel_last</span><span class="p">(),</span>
            <span class="n">imc</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">,</span>
            <span class="n">names</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">names</span><span class="p">,</span>
            <span class="n">title_im</span><span class="o">=</span><span class="n">title_im</span><span class="p">,</span>
            <span class="n">title_spectra</span><span class="o">=</span><span class="n">title_spectra</span><span class="p">,</span>
            <span class="n">xlabel</span><span class="o">=</span><span class="n">xlabel</span><span class="p">,</span>
            <span class="n">ylabel</span><span class="o">=</span><span class="n">ylabel</span><span class="p">,</span>
            <span class="n">callback</span><span class="o">=</span><span class="n">on_end_collect</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">series</span><span class="p">,</span> <span class="n">val_i</span><span class="p">,</span> <span class="n">val_j</span></div>
</div>



<div class="viewcode-block" id="InferenceTools">
<a class="viewcode-back" href="../../modules.html#rastereasy.InferenceTools">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InferenceTools</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility class for inference operations on raster images.</span>

<span class="sd">    This class provides methods for clustering, spectral adaptation</span>
<span class="sd">    fusion, ... of georeferenced images.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Perform K-means clustering on an image</span>
<span class="sd">    &gt;&gt;&gt; classified_img, model = InferenceTools.kmeans(image, n_clusters=5)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Adapt spectral properties of one image to match another</span>
<span class="sd">    &gt;&gt;&gt; adapted_img = InferenceTools.adapt(source_img, target_img, mapping=&#39;sinkhorn&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="InferenceTools.kmeans">
<a class="viewcode-back" href="../../modules.html#rastereasy.InferenceTools.kmeans">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kmeans</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">standardization</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform K-means clustering on a Geoimage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        im : Geoimage</span>
<span class="sd">            Input image to cluster</span>
<span class="sd">        n_clusters : int, optional</span>
<span class="sd">            Number of clusters (categories) to create.</span>
<span class="sd">            Default is 4.</span>
<span class="sd">        bands : list, optional</span>
<span class="sd">            List of bands to use for clustering. If None, all bands are used.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        random_state : int, optional</span>
<span class="sd">            Random state for reproducible results.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the clustered image.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        standardization : bool, optional</span>
<span class="sd">            Whether to standardize bands before clustering.</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with clusters as pixel values</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing the KMeans model and the scaler (if standardization was applied)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; classified_img, model = InferenceTools.kmeans(image, n_clusters=3)</span>
<span class="sd">        &gt;&gt;&gt; classified_img.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Clustering with specific bands</span>
<span class="sd">        &gt;&gt;&gt; classified_img, model = InferenceTools.kmeans(</span>
<span class="sd">        &gt;&gt;&gt;     image, n_clusters=4, bands=[&quot;8&quot;, &quot;2&quot;, &quot;1&quot;], random_state=42)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">im</span><span class="o">.</span><span class="n">kmeans</span><span class="p">(</span>
            <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span>
            <span class="n">bands</span><span class="o">=</span><span class="n">bands</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span>
            <span class="n">standardization</span><span class="o">=</span><span class="n">standardization</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="InferenceTools.fuse_dempster_shafer_2hypotheses">
<a class="viewcode-back" href="../../modules.html#rastereasy.InferenceTools.fuse_dempster_shafer_2hypotheses">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fuse_dempster_shafer_2hypotheses</span><span class="p">(</span><span class="o">*</span><span class="n">images</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fuse mass functions from multiple sources using Dempster-Shafer theory</span>
<span class="sd">        with two hypotheses: A and B.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *images : Geoimage</span>
<span class="sd">            Each input is a 3-band Geoimage.</span>

<span class="sd">            - Band 1: mass function m(A)</span>

<span class="sd">            - Band 2: mass function m(B)</span>

<span class="sd">            - Band 3: mass function m(A  B)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with 3 bands containing the fused mass functions:</span>
<span class="sd">            m(A), m(B), and m(A  B).</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with 1 band containing the conflict values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; fused, conflict = fuse_dempster_shafer_2hypotheses(im1, im2, im3)</span>
<span class="sd">        &gt;&gt;&gt; fused, conflict = fuse_dempster_shafer_2hypotheses(im1, im2, im3, im4)</span>
<span class="sd">        &gt;&gt;&gt; fused, conflict = fuse_dempster_shafer_2hypotheses(im1, im2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least two Geoimages are required for fusion.&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize outputs</span>
        <span class="n">im_fusion</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">im_conflict</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">select_bands</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">im_conflict</span><span class="o">.</span><span class="n">change_names</span><span class="p">({</span><span class="s1">&#39;conflict&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>

        <span class="c1"># Initial fusion</span>
        <span class="n">fusion</span><span class="p">,</span> <span class="n">conflict</span> <span class="o">=</span> <span class="n">fusion_2classes</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">(),</span> <span class="n">images</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">())</span>

        <span class="c1"># Fuse remaining sources</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">images</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="n">fusion</span><span class="p">,</span> <span class="n">conflict</span> <span class="o">=</span> <span class="n">fusion_2classes</span><span class="p">(</span><span class="n">fusion</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">())</span>

        <span class="c1"># Update Geoimages</span>
        <span class="n">im_fusion</span><span class="o">.</span><span class="n">upload_table</span><span class="p">(</span><span class="n">fusion</span><span class="p">)</span>

        <span class="n">im_conflict</span><span class="o">.</span><span class="n">upload_table</span><span class="p">(</span><span class="n">conflict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">im_fusion</span><span class="p">,</span> <span class="n">im_conflict</span></div>


<div class="viewcode-block" id="InferenceTools.adapt">
<a class="viewcode-back" href="../../modules.html#rastereasy.InferenceTools.adapt">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adapt</span><span class="p">(</span><span class="n">ims</span><span class="p">,</span> <span class="n">imt</span><span class="p">,</span> <span class="n">tab_source</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nb</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">reg_e</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">1e0</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjusts the spectral characteristics of a source image to match those of a target image</span>
<span class="sd">        using optimal transport methods.</span>

<span class="sd">        This function normalizes the data, applies the chosen optimal transport algorithm to</span>
<span class="sd">        adapt the spectral characteristics, and then restores the original data scale.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ims : Geoimage</span>
<span class="sd">            Source image whose spectral characteristics will be adjusted.</span>
<span class="sd">        imt : Geoimage or numpy.ndarray</span>
<span class="sd">            Target image serving as a reference for spectral adjustment,</span>
<span class="sd">            or a NumPy array of shape (N, bands) containing N spectral samples.</span>
<span class="sd">        tab_source : numpy.ndarray, optional</span>
<span class="sd">            Required if `imt` is a NumPy array. Must be an array of shape (M, bands)</span>
<span class="sd">            containing spectral samples from the source image.</span>
<span class="sd">        nb : int, optional</span>
<span class="sd">            Number of random samples used to train the transport model.</span>
<span class="sd">            Default is 1000.</span>
<span class="sd">        mapping : str, optional</span>
<span class="sd">            Optimal transport method to use. Available options:</span>
<span class="sd">            - &#39;emd&#39;: Earth Mover&#39;s Distance (more precise but slower)</span>
<span class="sd">            - &#39;sinkhorn&#39;: Sinkhorn transport with regularization (good balance)</span>
<span class="sd">            - &#39;mappingtransport&#39;: Mapping-based transport (flexible)</span>
<span class="sd">            - &#39;gaussian&#39;: Transport with Gaussian assumptions (faster, robust)</span>
<span class="sd">            Default is &#39;gaussian&#39;.</span>
<span class="sd">        reg_e : float, optional</span>
<span class="sd">            Regularization parameter for Sinkhorn transport.</span>
<span class="sd">            Default is 1e-1.</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">            Regularization parameter for mapping-based methods.</span>
<span class="sd">            Default is 1e0.</span>
<span class="sd">        eta : float, optional</span>
<span class="sd">            Learning rate for mapping-based transport methods.</span>
<span class="sd">            Default is 1e-2.</span>
<span class="sd">        bias : bool, optional</span>
<span class="sd">            Adds a bias term to the transport model if enabled.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        max_iter : int, optional</span>
<span class="sd">            Maximum number of iterations for iterative transport methods.</span>
<span class="sd">            Default is 20.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            Enables progress messages during processing.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        sigma : float, optional</span>
<span class="sd">            Standard deviation used for Gaussian transport methods.</span>
<span class="sd">            Default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new image where the spectral bands of the source image `ims` are</span>
<span class="sd">            adapted to match those of the target image `imt`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an unrecognized mapping method is specified.</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the adaptation process fails.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This function uses optimal transport tools (via the POT library).</span>
<span class="sd">        - Raster data is normalized before transport and then denormalized afterward.</span>
<span class="sd">        - Pixels with nodata values in both images are excluded from calculations.</span>
<span class="sd">        - Adjusted values are limited to remain within valid ranges.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; adapted_image = InferenceTools.adapt(source_image, target_image, mapping=&#39;sinkhorn&#39;, reg_e=0.01)</span>
<span class="sd">        &gt;&gt;&gt; adapted_image.save(&#39;adapted_image.tif&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Adaptation using sample arrays</span>
<span class="sd">        &gt;&gt;&gt; adapted_image = InferenceTools.adapt(source_image, tab_target, tab_source, mapping=&#39;sinkhorn&#39;, reg_e=0.01)</span>
<span class="sd">        &gt;&gt;&gt; adapted_image.save(&#39;adapted_image.tif&#39;)</span>
<span class="sd">        &gt;&gt;&gt; adapted_image.save(&#39;adapted_image.tif&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Adaptation using different methods</span>
<span class="sd">        &gt;&gt;&gt; adapted_gaussian = InferenceTools.adapt(source_image, target_image, mapping=&#39;gaussian&#39;)</span>
<span class="sd">        &gt;&gt;&gt; adapted_emd = InferenceTools.adapt(source_image, target_image, mapping=&#39;emd&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">ot</span>  <span class="c1"># Optimal transport library</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">RANDOM_STATE</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imt</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
                <span class="n">im1</span> <span class="o">=</span> <span class="n">ims</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">im1s</span><span class="p">,</span> <span class="n">scaler1</span> <span class="o">=</span> <span class="n">im1</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span>
                <span class="n">X1</span> <span class="o">=</span> <span class="n">im1s</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">()</span>
                <span class="n">mask1</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">X1</span> <span class="o">==</span> <span class="n">im1s</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">X1</span> <span class="o">=</span> <span class="n">X1</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">X1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nb</span><span class="p">:</span>
                    <span class="n">idx1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">X1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">nb</span><span class="p">,))</span>
                    <span class="n">Xs</span> <span class="o">=</span> <span class="n">X1</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Xs</span> <span class="o">=</span> <span class="n">X1</span>
                    <span class="n">im2</span> <span class="o">=</span> <span class="n">imt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">im2</span> <span class="o">=</span> <span class="n">imt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">im2s</span><span class="p">,</span> <span class="n">scaler2</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;minmax&#39;</span><span class="p">)</span>
                <span class="n">X2</span> <span class="o">=</span> <span class="n">im2s</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">()</span>
                <span class="n">mask2</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">X2</span> <span class="o">==</span> <span class="n">im2s</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">X2</span> <span class="o">=</span> <span class="n">X2</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">X2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nb</span><span class="p">:</span>
                    <span class="n">idx2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">X2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">nb</span><span class="p">,))</span>
                    <span class="n">Xt</span> <span class="o">=</span> <span class="n">X2</span><span class="p">[</span><span class="n">idx2</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Xt</span> <span class="o">=</span> <span class="n">X2</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">tab</span> <span class="o">=</span> <span class="n">tab_source</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">scaler1</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
                <span class="n">Xs</span> <span class="o">=</span> <span class="n">scaler1</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


                <span class="n">tab</span> <span class="o">=</span> <span class="n">imt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">scaler2</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
                <span class="n">Xt</span> <span class="o">=</span> <span class="n">scaler2</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Transport</span>
            <span class="k">if</span> <span class="n">mapping</span> <span class="o">==</span> <span class="s2">&quot;emd&quot;</span><span class="p">:</span>
                <span class="n">transport_data</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">da</span><span class="o">.</span><span class="n">EMDTransport</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">mapping</span> <span class="o">==</span> <span class="s2">&quot;sinkhorn&quot;</span><span class="p">:</span>
                <span class="n">transport_data</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">da</span><span class="o">.</span><span class="n">SinkhornTransport</span><span class="p">(</span><span class="n">reg_e</span><span class="o">=</span><span class="n">reg_e</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mapping</span> <span class="o">==</span> <span class="s2">&quot;mappingtransport&quot;</span><span class="p">:</span>
                <span class="n">transport_data</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">da</span><span class="o">.</span><span class="n">MappingTransport</span><span class="p">(</span>
                    <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">mapping</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
                <span class="n">transport_data</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">da</span><span class="o">.</span><span class="n">MappingTransport</span><span class="p">(</span>
                    <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Mapping type &quot;</span><span class="si">{</span><span class="n">mapping</span><span class="si">}</span><span class="s1">&quot; is not recognized. &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;Use &quot;emd&quot;, &quot;sinkhorn&quot;, &quot;mappingtransport&quot;, or &quot;gaussian&quot;.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitting transport model using </span><span class="si">{</span><span class="n">mapping</span><span class="si">}</span><span class="s2"> method...&quot;</span><span class="p">)</span>

            <span class="n">transport_data</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xs</span><span class="o">=</span><span class="n">Xs</span><span class="p">,</span> <span class="n">Xt</span><span class="o">=</span><span class="n">Xt</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transforming data...&quot;</span><span class="p">)</span>
            <span class="n">im1</span> <span class="o">=</span> <span class="n">ims</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">X1</span> <span class="o">=</span> <span class="n">im1</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">()</span>
            <span class="n">X1</span> <span class="o">=</span> <span class="n">scaler1</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">transp_Xs</span> <span class="o">=</span> <span class="n">transport_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Xs</span><span class="o">=</span><span class="n">X1</span><span class="p">)</span>

<span class="c1">#            Image = np.clip(table2image(transp_Xs, im1.shape, channel_first=True), 0., 1.)</span>
            <span class="n">Image</span> <span class="o">=</span> <span class="n">table2image</span><span class="p">(</span><span class="n">transp_Xs</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">im1</span><span class="o">.</span><span class="n">upload_image</span><span class="p">(</span><span class="n">Image</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">im1</span><span class="o">.</span><span class="n">get_names</span><span class="p">(),</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">im1</span> <span class="o">=</span> <span class="n">im1</span><span class="o">.</span><span class="n">inverse_standardize</span><span class="p">(</span><span class="n">scaler2</span><span class="p">)</span>

            <span class="n">im1</span> <span class="o">=</span> <span class="n">im1</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ims</span> <span class="o">==</span> <span class="n">ims</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">ims</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">im1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Adaptation complete.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">im1</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during spectral adaptation: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span></div>
</div>


<span class="k">def</span><span class="w"> </span><span class="nf">files2stack</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s1">&#39;jp2&#39;</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a stacked Geoimage from multiple single-band images.</span>

<span class="sd">    This function creates a multi-band Geoimage by stacking individual images,</span>
<span class="sd">    either from a list of image paths or from all images in a directory.</span>
<span class="sd">    All input images should have 1 band each.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imagefile_path : str or list of str</span>
<span class="sd">        - If a list of strings: paths to image files to stack (e.g., [&#39;image1.jp2&#39;, &#39;image2.jp2&#39;, ...])</span>
<span class="sd">        - If a string: path to a directory containing images with the specified extension</span>
<span class="sd">    resolution : float, optional</span>
<span class="sd">        Resolution to which all images will be resampled. If None, all images must</span>
<span class="sd">        have the same resolution already.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    names : dict or str, optional</span>
<span class="sd">        How to name the spectral bands in the stack:</span>
<span class="sd">        - If a dict: Maps band names to indices (e.g., {&#39;B&#39;: 1, &#39;G&#39;: 2, &#39;R&#39;: 3, ...})</span>
<span class="sd">        - If &quot;origin&quot; (default): Uses the original filenames as band names</span>
<span class="sd">        - If None: Assigns numeric names (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, ...)</span>
<span class="sd">        Default is &quot;origin&quot;.</span>
<span class="sd">    dest_name : str, optional</span>
<span class="sd">        Path to save the stacked image as a TIFF file.</span>
<span class="sd">        Default is None (no file saved).</span>
<span class="sd">    ext : str, optional</span>
<span class="sd">        File extension of images to load if imagefile_path is a directory.</span>
<span class="sd">        Default is &#39;jp2&#39;.</span>
<span class="sd">    history : bool, optional</span>
<span class="sd">        Whether to enable history tracking for the output Geoimage.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Geoimage</span>
<span class="sd">        A stacked Geoimage containing all the input images as bands.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Stack from a list of image files</span>
<span class="sd">    &gt;&gt;&gt; list_images = [&#39;band1.jp2&#39;, &#39;band2.jp2&#39;, &#39;band3.jp2&#39;]</span>
<span class="sd">    &gt;&gt;&gt; stacked_image = files2stack(list_images)</span>
<span class="sd">    &gt;&gt;&gt; stacked_image.save(&#39;stacked.tif&#39;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Stack all jp2 files from a directory with resolution resampling</span>
<span class="sd">    &gt;&gt;&gt; folder_path = &#39;./my_bands_folder&#39;</span>
<span class="sd">    &gt;&gt;&gt; stacked_image = files2stack(folder_path, resolution=10)</span>
<span class="sd">    &gt;&gt;&gt; stacked_image.info()</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is particularly useful for combining separate band files (common in</span>
<span class="sd">    satellite imagery) into a single multi-band image for analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Handle input as string (directory) or list of files</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">imagefile_path</span> <span class="o">=</span> <span class="n">list_fles</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;imagefile_path should be a list of file paths or a string with a folder path&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No files with extension &#39;</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&#39; found in the specified path&quot;</span><span class="p">)</span>

    <span class="c1"># Case 1: No resampling needed (all images must have same resolution)</span>
    <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Initialize with first image</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Stack remaining images</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">im</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">Geoimage</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Handle band naming</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">names</span> <span class="o">==</span> <span class="s1">&#39;origin&#39;</span><span class="p">:</span>
                <span class="c1"># Use filenames as band names</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file</span><span class="p">))[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                         <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">)}</span>

                <span class="c1"># Check for duplicated names</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">im</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Original filenames contain duplicates. Using sequential names instead. &quot;</span>
                                 <span class="s2">&quot;To suppress this warning, use names=None.&quot;</span><span class="p">,</span>
                                 <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">)</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">)):</span>
                        <span class="n">names</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Apply band names</span>
            <span class="n">im</span><span class="o">.</span><span class="n">change_names</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="c1"># Enable history if requested</span>
        <span class="k">if</span> <span class="n">history</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">activate_history</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">im</span>

    <span class="c1"># Case 2: Resampling required</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Initialize with first image (resampled)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">resolution</span> <span class="o">!=</span> <span class="n">resolution</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">resampling</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Process remaining images</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Load and resample next image</span>
            <span class="n">im_tmpo</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">im_tmpo</span><span class="o">.</span><span class="n">resolution</span> <span class="o">!=</span> <span class="n">resolution</span><span class="p">:</span>
                <span class="n">im_tmpo</span><span class="o">.</span><span class="n">resampling</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Extract common areas and stack</span>
            <span class="n">im</span><span class="p">,</span> <span class="n">im_tmpo</span> <span class="o">=</span> <span class="n">extract_common_areas</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">im_tmpo</span><span class="p">)</span>
            <span class="n">im</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">im_tmpo</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Handle band naming</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">names</span> <span class="o">==</span> <span class="s1">&#39;origin&#39;</span><span class="p">:</span>
                <span class="c1"># Use filenames as band names</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file</span><span class="p">))[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                         <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">)}</span>

                <span class="c1"># Check for duplicated names</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">im</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Original filenames contain duplicates. Using sequential names instead. &quot;</span>
                                 <span class="s2">&quot;To suppress this warning, use names=None.&quot;</span><span class="p">,</span>
                                 <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">)</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">imagefile_path</span><span class="p">)):</span>
                        <span class="n">names</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Apply band names</span>
            <span class="n">im</span><span class="o">.</span><span class="n">change_names</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="c1"># Enable history if requested</span>
        <span class="k">if</span> <span class="n">history</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">activate_history</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">im</span>


<span class="k">def</span><span class="w"> </span><span class="nf">extract_common_areas</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract the overlapping area between two GeoImages.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im1 : Geoimage</span>
<span class="sd">        First input image</span>
<span class="sd">    im2 : Geoimage</span>
<span class="sd">        Second input image</span>
<span class="sd">    resolution : {&#39;min&#39;, &#39;max&#39;, None}, optional</span>
<span class="sd">        How to handle resolution differences:</span>
<span class="sd">        - &#39;min&#39;: Use the more precise (smaller pixel size) resolution</span>
<span class="sd">        - &#39;max&#39;: Use the less precise (larger pixel size) resolution</span>
<span class="sd">        - None: Keep original resolutions</span>
<span class="sd">        Default is &#39;min&#39;.</span>
<span class="sd">    projection : str, optional</span>
<span class="sd">        Projection system for output images. If None, uses im1&#39;s projection.</span>
<span class="sd">        Example: &quot;EPSG:4326&quot;</span>
<span class="sd">        Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Geoimage, Geoimage</span>
<span class="sd">        Two new Geoimages containing only the common overlapping area</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Extract common area with smallest pixel size</span>
<span class="sd">    &gt;&gt;&gt; common_im1, common_im2 = extract_common_areas(image1, image2)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Extract common area with specific projection</span>
<span class="sd">    &gt;&gt;&gt; common_im1, common_im2 = extract_common_areas(image1, image2, projection=&quot;EPSG:4326&quot;)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is useful for preparing images for analysis or comparison when</span>
<span class="sd">    they cover different geographical areas but have an overlapping region.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Handle different projections</span>
    <span class="n">adapt</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">im1</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">im2</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()[</span><span class="s1">&#39;crs&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="n">projection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">projection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im1</span> <span class="o">=</span> <span class="n">im1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">im2</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">im1</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">im2</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im2</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">im2</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">im1</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Handle different resolutions</span>
    <span class="k">if</span> <span class="n">im1</span><span class="o">.</span><span class="n">resolution</span> <span class="o">!=</span> <span class="n">im2</span><span class="o">.</span><span class="n">resolution</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">adapt</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">resolution</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">im1</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">resolution</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">resolution</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">im1</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">resolution</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: resolution </span><span class="si">{</span><span class="n">resolution</span><span class="si">}</span><span class="s1"> unknown. Use &quot;min&quot;, &quot;max&quot;, or None.&#39;</span><span class="p">)</span>

            <span class="n">im1</span> <span class="o">=</span> <span class="n">im1</span><span class="o">.</span><span class="n">resampling</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="n">im2</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">resampling</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="c1"># Get corner coordinates</span>
    <span class="n">lat1_d</span><span class="p">,</span> <span class="n">lon1_d</span> <span class="o">=</span> <span class="n">im1</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">lat1_e</span><span class="p">,</span> <span class="n">lon1_e</span> <span class="o">=</span> <span class="n">im1</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">lat2_d</span><span class="p">,</span> <span class="n">lon2_d</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">lat2_e</span><span class="p">,</span> <span class="n">lon2_e</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Calculate boundaries of overlapping area</span>
    <span class="n">bound_lat_d</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lat1_d</span><span class="p">,</span> <span class="n">lat2_d</span><span class="p">)</span>
    <span class="n">bound_lat_e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lat1_e</span><span class="p">,</span> <span class="n">lat2_e</span><span class="p">)</span>
    <span class="n">bound_lon_d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lon1_d</span><span class="p">,</span> <span class="n">lon2_d</span><span class="p">)</span>
    <span class="n">bound_lon_e</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lon1_e</span><span class="p">,</span> <span class="n">lon2_e</span><span class="p">)</span>

    <span class="c1"># Crop images to common bounds</span>
    <span class="n">im1common</span> <span class="o">=</span> <span class="n">im1</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">bound_lon_d</span><span class="p">,</span> <span class="n">bound_lon_e</span><span class="p">,</span> <span class="n">bound_lat_d</span><span class="p">,</span> <span class="n">bound_lat_e</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">im2common</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">bound_lon_d</span><span class="p">,</span> <span class="n">bound_lon_e</span><span class="p">,</span> <span class="n">bound_lat_d</span><span class="p">,</span> <span class="n">bound_lat_e</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Adjust for srowht differences in size after reprojection/resampling</span>
    <span class="k">if</span> <span class="n">adapt</span><span class="p">:</span>
        <span class="n">im1common</span><span class="p">,</span> <span class="n">im2common</span> <span class="o">=</span> <span class="n">ajust_sizes</span><span class="p">(</span><span class="n">im1common</span><span class="p">,</span> <span class="n">im2common</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">im1common</span><span class="p">,</span> <span class="n">im2common</span>


<span class="k">def</span><span class="w"> </span><span class="nf">extend_common_areas</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extend two images to cover their combined area, filling new areas with nodata value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image1 : Geoimage</span>
<span class="sd">        First input image</span>
<span class="sd">    image2 : Geoimage</span>
<span class="sd">        Second input image</span>
<span class="sd">    nodata_value : int or float, optional</span>
<span class="sd">        Value to use for areas outside the original image bounds.</span>
<span class="sd">        Default is 0.</span>
<span class="sd">    resolution : {&#39;min&#39;, &#39;max&#39;}, optional</span>
<span class="sd">        How to handle resolution differences:</span>
<span class="sd">        - &#39;min&#39;: Use the more precise (smaller pixel size) resolution</span>
<span class="sd">        - &#39;max&#39;: Use the less precise (larger pixel size) resolution</span>
<span class="sd">        Default is &#39;min&#39;.</span>
<span class="sd">    projection : str, optional</span>
<span class="sd">        Projection to use for output images. If None, uses image1&#39;s projection.</span>
<span class="sd">        Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Geoimage, Geoimage</span>
<span class="sd">        Two new Geoimages, each covering the combined area of both input images</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; extended_im1, extended_im2 = extend_common_areas(image1, image2)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is useful for preparing images with different extents for comparison</span>
<span class="sd">    or mathematical operations that require the same dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Handle different projections</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">image1</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">image2</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()[</span><span class="s1">&#39;crs&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="n">projection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">projection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image1</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">image2</span> <span class="o">=</span> <span class="n">image2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">image1</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">image2</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image2</span> <span class="o">=</span> <span class="n">image2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">image2</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="n">image1</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Handle different resolutions</span>
    <span class="k">if</span> <span class="n">image1</span><span class="o">.</span><span class="n">resolution</span> <span class="o">!=</span> <span class="n">image2</span><span class="o">.</span><span class="n">resolution</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">image1</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">image2</span><span class="o">.</span><span class="n">resolution</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">resolution</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">image1</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">image2</span><span class="o">.</span><span class="n">resolution</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: resolution </span><span class="si">{</span><span class="n">resolution</span><span class="si">}</span><span class="s1"> unknown. Use &quot;min&quot; or &quot;max&quot;.&#39;</span><span class="p">)</span>

        <span class="n">image1</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">resampling</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="n">image2</span> <span class="o">=</span> <span class="n">image2</span><span class="o">.</span><span class="n">resampling</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="c1"># Get the image data and metadata</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">image</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">image2</span><span class="o">.</span><span class="n">image</span>
    <span class="n">meta1</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span>
    <span class="n">meta2</span> <span class="o">=</span> <span class="n">image2</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span>

    <span class="c1"># Calculate common bounds</span>
    <span class="n">bounds1</span> <span class="o">=</span> <span class="n">rio</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">array_bounds</span><span class="p">(</span><span class="n">meta1</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="n">meta1</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">],</span> <span class="n">meta1</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">])</span>
    <span class="n">bounds2</span> <span class="o">=</span> <span class="n">rio</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">array_bounds</span><span class="p">(</span><span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">],</span> <span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">])</span>

    <span class="c1"># Create union bounds (combined area)</span>
    <span class="n">union_bounds</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">min</span><span class="p">(</span><span class="n">bounds1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># xmin</span>
        <span class="nb">min</span><span class="p">(</span><span class="n">bounds1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bounds2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>  <span class="c1"># ymin</span>
        <span class="nb">max</span><span class="p">(</span><span class="n">bounds1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds2</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>  <span class="c1"># xmax</span>
        <span class="nb">max</span><span class="p">(</span><span class="n">bounds1</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bounds2</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>   <span class="c1"># ymax</span>
    <span class="p">)</span>

    <span class="c1"># Create new transformation with union bounds</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">meta1</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Use resolution from first image</span>
    <span class="n">new_transform</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span>
        <span class="o">*</span><span class="n">union_bounds</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">union_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">union_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">res</span><span class="p">),</span>
        <span class="n">height</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">union_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">union_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Calculate dimensions of new images</span>
    <span class="n">new_height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">union_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">union_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">new_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">union_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">union_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">res</span><span class="p">)</span>

    <span class="c1"># Create new arrays filled with nodata value</span>
    <span class="n">im1_extend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">meta1</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span> <span class="n">new_height</span><span class="p">,</span> <span class="n">new_width</span><span class="p">),</span> <span class="n">nodata_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">im1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">im2_extend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span> <span class="n">new_height</span><span class="p">,</span> <span class="n">new_width</span><span class="p">),</span> <span class="n">nodata_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">im2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Reproject original data into the new arrays</span>
    <span class="n">reproject</span><span class="p">(</span>
        <span class="n">source</span><span class="o">=</span><span class="n">im1</span><span class="p">,</span>
        <span class="n">destination</span><span class="o">=</span><span class="n">im1_extend</span><span class="p">,</span>
        <span class="n">src_transform</span><span class="o">=</span><span class="n">meta1</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">],</span>
        <span class="n">dst_transform</span><span class="o">=</span><span class="n">new_transform</span><span class="p">,</span>
        <span class="n">src_crs</span><span class="o">=</span><span class="n">meta1</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">],</span>
        <span class="n">dst_crs</span><span class="o">=</span><span class="n">meta1</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">],</span>
        <span class="n">nodata</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">,</span>
        <span class="n">resampling</span><span class="o">=</span><span class="n">Resampling</span><span class="o">.</span><span class="n">nearest</span>
    <span class="p">)</span>

    <span class="n">reproject</span><span class="p">(</span>
        <span class="n">source</span><span class="o">=</span><span class="n">im2</span><span class="p">,</span>
        <span class="n">destination</span><span class="o">=</span><span class="n">im2_extend</span><span class="p">,</span>
        <span class="n">src_transform</span><span class="o">=</span><span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">],</span>
        <span class="n">dst_transform</span><span class="o">=</span><span class="n">new_transform</span><span class="p">,</span>
        <span class="n">src_crs</span><span class="o">=</span><span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">],</span>
        <span class="n">dst_crs</span><span class="o">=</span><span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">],</span>
        <span class="n">nodata</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">,</span>
        <span class="n">resampling</span><span class="o">=</span><span class="n">Resampling</span><span class="o">.</span><span class="n">nearest</span>
    <span class="p">)</span>

    <span class="c1"># Create new metadata</span>
    <span class="n">new_meta</span> <span class="o">=</span> <span class="n">meta1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_meta</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">new_height</span><span class="p">,</span>
        <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">new_width</span><span class="p">,</span>
        <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">new_transform</span><span class="p">,</span>
        <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">nodata_value</span>
    <span class="p">})</span>

    <span class="c1"># Create and return new Geoimage objects</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">im1_extend</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">new_meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">image1</span><span class="o">.</span><span class="n">names</span><span class="p">),</span>
        <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">im2_extend</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">new_meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">image2</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
    <span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">colorcomp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">name_save</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fig_size</span><span class="o">=</span><span class="n">DEF_FIG_SIZE</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a color composite visualization from a multi-band image.</span>

<span class="sd">    This function generates an RGB color composite from a multi-band image by selecting</span>
<span class="sd">    three bands to represent red, green, and blue channels. The image can be displayed</span>
<span class="sd">    and/or saved as a file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : numpy.ndarray</span>
<span class="sd">        Input image data as a 3D array.</span>
<span class="sd">    bands : list of str</span>
<span class="sd">        List of three band identifiers to use for the RGB composite. Can be either:</span>
<span class="sd">        - Band names (e.g., [&quot;R&quot;, &quot;G&quot;, &quot;B&quot;]) if `names` dictionary is provided</span>
<span class="sd">        - Band indices as strings (e.g., [&quot;4&quot;, &quot;3&quot;, &quot;2&quot;])</span>
<span class="sd">    name_save : str, optional</span>
<span class="sd">        Path to save the color composite image. If empty, image is not saved.</span>
<span class="sd">        Default is &#39;&#39;.</span>
<span class="sd">    names : dict, optional</span>
<span class="sd">        Dictionary mapping band names to band indices (e.g., {&#39;R&#39;: 4, &#39;G&#39;: 3, &#39;B&#39;: 2}).</span>
<span class="sd">        Required if using band names in the `bands` parameter.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    percentile : int, optional</span>
<span class="sd">        Percentile value for contrast stretching (e.g., 2 for a 2-98% stretch).</span>
<span class="sd">        Default is 2.</span>
<span class="sd">    channel_first : bool, optional</span>
<span class="sd">        Whether input image has shape (bands, rows, cols). If False, assumes</span>
<span class="sd">        shape (rows, cols, bands).</span>
<span class="sd">        Default is True.</span>
<span class="sd">    meta : dict, optional</span>
<span class="sd">        Metadata dictionary (required if saving the image).</span>
<span class="sd">        Default is None.</span>
<span class="sd">    fig_size : tuple, optional</span>
<span class="sd">        Size of the figure in inches as (width, height).</span>
<span class="sd">        Default is DEF_FIG_SIZE.</span>
<span class="sd">    title : str, optional</span>
<span class="sd">        Title for the visualization.</span>
<span class="sd">        Default is &#39;&#39;.</span>
<span class="sd">    extent : list or None, optional</span>
<span class="sd">        The extent of coordinates as [xmin, xmax, ymin, ymax]. If None, no extent is shown.</span>
<span class="sd">        Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        Function displays and/or saves the color composite but doesn&#39;t return any values.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If meta is None when trying to save the image.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Create and display a false color composite</span>
<span class="sd">    &gt;&gt;&gt; colorcomp(image, bands=[&quot;NIR&quot;, &quot;R&quot;, &quot;G&quot;], names={&#39;R&#39;: 3, &#39;G&#39;: 2, &#39;B&#39;: 1, &#39;NIR&#39;: 4})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Create, display and save a natural color composite</span>
<span class="sd">    &gt;&gt;&gt; colorcomp(image, bands=[&quot;3&quot;, &quot;2&quot;, &quot;1&quot;], name_save=&quot;rgb_composite.tif&quot;, meta=metadata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Reset matplotlib settings to avoid interference from previous plots</span>
    <span class="n">reset_matplotlib</span><span class="p">()</span>

    <span class="c1"># Convert image to channel_last format if needed</span>
    <span class="k">if</span> <span class="n">channel_first</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Create band name mapping if not provided</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">names</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Create empty RGB image</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># Populate RGB channels with normalized band values</span>
    <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">names</span><span class="p">[</span><span class="n">bands</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">percentile</span><span class="p">)</span>
    <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">names</span><span class="p">[</span><span class="n">bands</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">percentile</span><span class="p">)</span>
    <span class="n">im</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">names</span><span class="p">[</span><span class="n">bands</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">percentile</span><span class="p">)</span>

    <span class="c1"># Save image if requested</span>
    <span class="k">if</span> <span class="n">name_save</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error: you need to provide meta info to save the image&quot;</span><span class="p">)</span>

        <span class="c1"># Prepare for saving</span>
        <span class="n">imt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">meta2</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;uint8&#39;</span>
        <span class="n">meta2</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Create folder if it doesn&#39;t exist</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">name_save</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">folder</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>

        <span class="c1"># Remove existing files</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">name_save</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name_save</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name_save</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name_save</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">)</span>

        <span class="c1"># Write the color composite</span>
        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">name_save</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta2</span><span class="p">)</span> <span class="k">as</span> <span class="n">outds</span><span class="p">:</span>
            <span class="n">outds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">imt</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Image saved in&quot;</span><span class="p">,</span> <span class="n">name_save</span><span class="p">)</span>

    <span class="c1"># Display the image</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="c1">#plt.close(fig)</span>

<div class="viewcode-block" id="Geoimage">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Geoimage</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main class for manipulating georeferenced raster images.</span>

<span class="sd">    This class provides a comprehensive toolkit for working with geospatial raster data,</span>
<span class="sd">    supporting operations such as image creation, visualization, band manipulation,</span>
<span class="sd">    reprojection, resampling, cropping, and more.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_name : str, optional</span>
<span class="sd">        Path to a GeoTIFF image file to load. If provided, the image data and metadata</span>
<span class="sd">        will be read from this file.</span>
<span class="sd">    names : dict, optional</span>
<span class="sd">        Dictionary mapping band names to band indices (e.g., {&#39;NIR&#39;: 1, &#39;R&#39;: 2, &#39;G&#39;: 3}).</span>
<span class="sd">        If not provided, bands will be named numerically (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, ...).</span>
<span class="sd">    history : bool, optional</span>
<span class="sd">        Whether to track modification history for the image.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    data : numpy.ndarray, optional</span>
<span class="sd">        Image data to initialize the object with. Must be provided with `meta`.</span>
<span class="sd">        Shape should be (bands, rows, cols).</span>
<span class="sd">    meta : dict, optional</span>
<span class="sd">        Metadata dictionary containing rasterio metadata fields (e.g., crs, transform).</span>
<span class="sd">        Required if `data` is provided.</span>
<span class="sd">    georef : bool, optional</span>
<span class="sd">        Whether the image is georeferenced. If None, will be determined from metadata.</span>
<span class="sd">    target_crs : str, optional</span>
<span class="sd">        Target coordinate reference system if reprojection is needed during loading.</span>
<span class="sd">        Default is &quot;EPSG:4326&quot;.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    image : numpy.ndarray</span>
<span class="sd">        The image data array with shape (bands, rows, cols).</span>
<span class="sd">    shape : tuple</span>
<span class="sd">        The dimensions of the image as (rows, cols).</span>
<span class="sd">    nb_bands : int</span>
<span class="sd">        The number of spectral bands in the image.</span>
<span class="sd">    resolution : float</span>
<span class="sd">        The spatial resolution of the image (pixel size in map units).</span>
<span class="sd">    names : dict</span>
<span class="sd">        Dictionary mapping band names to band indices.</span>
<span class="sd">    nodata : float or int</span>
<span class="sd">        Value used to represent no data or invalid pixels.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Create a Geoimage from a file</span>
<span class="sd">    &gt;&gt;&gt; img = Geoimage(&quot;landsat_image.tif&quot;)</span>
<span class="sd">    &gt;&gt;&gt; img.info()</span>
<span class="sd">    &gt;&gt;&gt; # Create a Geoimage from a NumPy array with metadata</span>
<span class="sd">    &gt;&gt;&gt; meta = {&#39;driver&#39;: &#39;GTiff&#39;, &#39;width&#39;: 100, &#39;height&#39;: 100, &#39;count&#39;: 3,</span>
<span class="sd">    &gt;&gt;&gt; ...         &#39;crs&#39;: CRS.from_epsg(4326), &#39;transform&#39;: Affine(0.1, 0, 0, 0, -0.1, 0)}</span>
<span class="sd">    &gt;&gt;&gt; data = np.zeros((3, 100, 100))</span>
<span class="sd">    &gt;&gt;&gt; img = Geoimage(data=data, meta=meta)</span>
<span class="sd">    &gt;&gt;&gt; # Create a Geoimage with custom band names</span>
<span class="sd">    &gt;&gt;&gt; img = Geoimage(&quot;landsat_image.tif&quot;, names={&#39;R&#39;: 1, &#39;G&#39;: 2, &#39;B&#39;: 3, &#39;NIR&#39;: 4})</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Geoimage.__init__">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a Geoimage object from a file or data array with metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">source_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Case 1: Loading from rst/rdc file format</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">source_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.rst&#39;</span><span class="p">,</span> <span class="s1">&#39;.rdc&#39;</span><span class="p">]):</span>
                <span class="n">name_rst</span><span class="p">,</span> <span class="n">name_rdc</span> <span class="o">=</span> <span class="n">find_rst_and_rdc</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">source_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span> <span class="o">=</span> <span class="n">read_rst_with_rdc</span><span class="p">(</span><span class="n">name_rst</span><span class="p">,</span> <span class="n">name_rdc</span><span class="p">,</span> <span class="n">target_crs</span><span class="o">=</span><span class="n">target_crs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__georef</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Case 2: Loading from standard geotiff file</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">src</span> <span class="o">=</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">source_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Image not georeferenced. Some functions may not work.&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__georef</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__georef</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span>

        <span class="c1"># Case 3: Creating from provided data and metadata</span>
        <span class="k">elif</span> <span class="n">meta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span> <span class="o">=</span> <span class="n">meta</span>
            <span class="k">if</span> <span class="n">georef</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__georef</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__georef</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Ensure data is in the correct shape (bands, rows, cols)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span>

                <span class="c1"># Validate dimensions match metadata</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error: metadata dimensions do not match data dimensions&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Create empty image with dimensions from metadata</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either source_name or both data and meta must be provided&quot;</span><span class="p">)</span>

        <span class="c1"># Set nodata value from metadata if available</span>
        <span class="k">if</span> <span class="s2">&quot;nodata&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Setup history tracking</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="o">=</span> <span class="n">history</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">source_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Read image </span><span class="si">{</span><span class="n">source_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created image from data array&#39;</span><span class="p">)</span>

        <span class="c1"># Setup band names</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update_names</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: the number of given names (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;the number of spectral bands (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">lowest_value_dict</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: the lowest value of the names should be 1 &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;(currently </span><span class="si">{</span><span class="n">lowest_value_dict</span><span class="p">(</span><span class="n">names</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">reorder_dict_by_values</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># Update derived properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update derived properties after changes to the image or metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">reorder_dict_by_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># Compute extent for visualization</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">:</span>
            <span class="n">limx</span><span class="p">,</span> <span class="n">limy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">limxm</span><span class="p">,</span> <span class="n">limym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">limx</span> <span class="o">==</span> <span class="n">limxm</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">limy</span> <span class="o">==</span> <span class="n">limym</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__extent_latlon</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__extent_pixels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__extent_latlon</span> <span class="o">=</span> <span class="p">[</span><span class="n">limy</span><span class="p">,</span> <span class="n">limym</span><span class="p">,</span> <span class="n">limx</span><span class="p">,</span> <span class="n">limxm</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__extent_pixels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__extent_latlon</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__extent_pixels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># Validate number of bands</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of band names given (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span><span class="si">}</span><span class="s1">) &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;does not match number of bands (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

        <span class="c1"># Update nodata value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__update_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize or update band names to default numeric sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable indexing into the Geoimage to get pixel values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : tuple or slice</span>
<span class="sd">            - If a tuple (row, col): returns all band values at that pixel</span>
<span class="sd">            - If slice [:]: returns the entire image array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The selected pixel values or full image array</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Get all band values for a specific pixel</span>
<span class="sd">        &gt;&gt;&gt; values = image[100, 200]  # Values at row 100, col 200</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Get the entire image array</span>
<span class="sd">        &gt;&gt;&gt; array = image[:]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># Corresponds to [:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">index</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable setting values in the image using boolean masks.</span>

<span class="sd">        This allows for conditional assignment operations like:</span>
<span class="sd">        image[image &gt; 100] = 100  # Clip values above 100</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        condition : Geoimage or boolean array</span>
<span class="sd">            Boolean mask indicating which pixels to modify</span>
<span class="sd">        value : number, array, or Geoimage</span>
<span class="sd">            Value(s) to assign to the selected pixels</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Clip values above 100</span>
<span class="sd">        &gt;&gt;&gt; image[image &gt; 100] = 100</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Set all water pixels (value 1) to a different value</span>
<span class="sd">        &gt;&gt;&gt; image[image == 1] = 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>


    <span class="c1">#------ Arithmetic and Comparison Operators ------#</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add another Geoimage or a scalar value to this image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to add</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the addition</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Add two images</span>
<span class="sd">        &gt;&gt;&gt; combined_image = image1 + image2</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Add a constant to an image</span>
<span class="sd">        &gt;&gt;&gt; brightened_image = image + 100</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="c1"># Add two Geoimages</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="c1"># Add a scalar to a Geoimage</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">+</span> <span class="n">other</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operand type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract another Geoimage or a scalar value from this image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to subtract</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the subtraction</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Subtract one image from another</span>
<span class="sd">        &gt;&gt;&gt; difference_image = image1 - image2</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Subtract a constant from an image</span>
<span class="sd">        &gt;&gt;&gt; darkened_image = image - 50</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">other</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operand type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply this image by another Geoimage or a scalar value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to multiply by</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the multiplication</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Multiply two images (e.g., for masking)</span>
<span class="sd">        &gt;&gt;&gt; masked_image = image1 * image2</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Scale an image by a factor</span>
<span class="sd">        &gt;&gt;&gt; scaled_image = image * 2.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operand type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide this image by another Geoimage or a scalar value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to divide by</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the division</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Divide one image by another (e.g., for ratio calculations)</span>
<span class="sd">        &gt;&gt;&gt; ndvi = (nir - red) / (nir + red)  # Normalized Difference Vegetation Index</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Scale an image by a divisor</span>
<span class="sd">        &gt;&gt;&gt; halved_image = image / 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">other</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operand type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform integer division of this image by another Geoimage or a scalar value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to divide by</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the integer division</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Integer division of images</span>
<span class="sd">        &gt;&gt;&gt; result = image1 // image2</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Integer division by a scalar</span>
<span class="sd">        &gt;&gt;&gt; result = image // 10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">//</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">//</span> <span class="n">other</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operand type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise this image to the power of another Geoimage or a scalar value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to use as the exponent</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the power operation</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Square an image</span>
<span class="sd">        &gt;&gt;&gt; squared_image = image ** 2</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Raise image to a variable power</span>
<span class="sd">        &gt;&gt;&gt; variable_power = image1 ** image2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">**</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">**</span> <span class="n">other</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operand type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#------ Comparison Operators ------#</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise less than comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to compare against</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing boolean results of the comparison</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Find pixels with values less than 100</span>
<span class="sd">        &gt;&gt;&gt; mask = image &lt; 100</span>
<span class="sd">        &gt;&gt;&gt; mask.visu()  # Visualize the mask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">&lt;</span> <span class="n">other</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise less than or equal comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to compare against</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing boolean results of the comparison</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">&lt;=</span> <span class="n">other</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise greater than comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to compare against</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing boolean results of the comparison</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Find pixels with values greater than a threshold</span>
<span class="sd">        &gt;&gt;&gt; high_values = image &gt; 200</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">&gt;</span> <span class="n">other</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise greater than or equal comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to compare against</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing boolean results of the comparison</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">&gt;=</span> <span class="n">other</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise equality comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to compare against</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing boolean results of the comparison</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a mask for pixels with a specific value</span>
<span class="sd">        &gt;&gt;&gt; water_mask = image == 1  # Assuming water is coded as 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">other</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Element-wise not-equal comparison.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage or scalar</span>
<span class="sd">            The image or value to compare against</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing boolean results of the comparison</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">!=</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Negate the image (multiply by -1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the negated values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Negate all values in an image</span>
<span class="sd">        &gt;&gt;&gt; negative_image = -image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span>
                      <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>


    <span class="c1">#------ Reversible Operators and Bitwise Operators ------#</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse addition operator (for cases like 5 + image).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : scalar</span>
<span class="sd">            The value to add to this image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the addition</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; brightened_image = 100 + image  # Same as image + 100</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse multiplication operator (for cases like 2 * image).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : scalar</span>
<span class="sd">            The value to multiply this image by</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the multiplication</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; doubled_image = 2 * image  # Same as image * 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse subtraction operator (for cases like 100 - image).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : scalar or Geoimage</span>
<span class="sd">            The value to subtract this image from</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the subtraction</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; inverse_difference = 255 - image  # Image negative/inverse for 8-bit data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">other</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operand type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse division operator (for cases like 1 / image).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : scalar or Geoimage</span>
<span class="sd">            The value to divide by this image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the division</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; reciprocal_image = 1 / image  # Reciprocal of each pixel value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operand type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse integer division operator (for cases like 100 // image).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : scalar or Geoimage</span>
<span class="sd">            The value to floor-divide by this image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the integer division</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; result = 100 // image  # Integer division of 100 by each pixel value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">other</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                          <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operand type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#------ Bitwise Operators ------#</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bitwise OR operation between images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage</span>
<span class="sd">            The image to OR with this image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the OR operation</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; combined_mask = mask1 | mask2  # Pixels that are in either mask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bitwise AND operation between images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage</span>
<span class="sd">            The image to AND with this image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the AND operation</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; overlap_mask = mask1 &amp; mask2  # Pixels that are in both masks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">&amp;</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bitwise XOR operation between images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage</span>
<span class="sd">            The image to XOR with this image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the XOR operation</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; exclusive_mask = mask1 ^ mask2  # Pixels that are in only one of the masks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">^</span> <span class="n">other</span><span class="o">.</span><span class="n">image</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bitwise NOT operation (invert all bits).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the inverted values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; inverted_mask = ~mask  # Invert a binary mask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                      <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                      <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

<div class="viewcode-block" id="Geoimage.where">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.where">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select values based on a condition, similar to numpy.where().</span>

<span class="sd">        This method allows for conditional operations, selecting values from</span>
<span class="sd">        `value1` where `condition` is True, and from `value2` where it&#39;s False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        condition : Geoimage</span>
<span class="sd">            Boolean mask indicating where to select values from `value1`</span>
<span class="sd">        value1 : Geoimage or scalar</span>
<span class="sd">            Values to use where condition is True</span>
<span class="sd">        value2 : Geoimage or scalar</span>
<span class="sd">            Values to use where condition is False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            New Geoimage containing the result of the conditional selection</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a cloud-free composite from two images</span>
<span class="sd">        &gt;&gt;&gt; cloud_free = image1.where(cloud_mask, image2, image1)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Threshold an image</span>
<span class="sd">        &gt;&gt;&gt; thresholded = image.where(image &gt; 100, 255, 0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tab_condition</span> <span class="o">=</span> <span class="n">match_dimensions</span><span class="p">(</span><span class="n">condition</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value2</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tab_condition</span><span class="p">,</span> <span class="n">value1</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">value2</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value2</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tab_condition</span><span class="p">,</span> <span class="n">value1</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">value2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value2</span><span class="p">,</span> <span class="n">Geoimage</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tab_condition</span><span class="p">,</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tab_condition</span><span class="p">,</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">)</span>

        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapt_nodata</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                       <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.update_from">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.update_from">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the current Geoimage with the attributes from another Geoimage.</span>

<span class="sd">        This method copies all attributes from the `other` Geoimage to this one,</span>
<span class="sd">        effectively replacing this image&#39;s content with that of `other`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoimage</span>
<span class="sd">            The Geoimage to copy attributes from</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            This method modifies the current object in place</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; result = image1.where(mask, 0, image1)  # Create a masked copy</span>
<span class="sd">        &gt;&gt;&gt; image1.update_from(result)  # Update the original with the masked version</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.reset_names">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.reset_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the band names to sequential numbers (&quot;1&quot;, &quot;2&quot;, ...).</span>

<span class="sd">        This method is useful when multiple stacks, removals, or additions of bands</span>
<span class="sd">        have left the band naming confusing or inconsistent.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Geoimage</span>
<span class="sd">            The method returns the object itself to allow method chaining</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; stacked_image = image1.apply_stack(image2)</span>
<span class="sd">        &gt;&gt;&gt; stacked_image.reset_names()</span>
<span class="sd">        &gt;&gt;&gt; stacked_image.info()  # Shows bands renamed to &quot;1&quot;, &quot;2&quot;, ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">initialize_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Reset names of bands&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Geoimage.change_nodata">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.change_nodata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">change_nodata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodatavalue</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify the no-data value of the image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodatavalue : float or int</span>
<span class="sd">            The new no-data value to assign</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Geoimage</span>
<span class="sd">            The method returns the object itself to allow method chaining</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; image.change_nodata(np.nan)  # Use NaN as nodata</span>
<span class="sd">        &gt;&gt;&gt; image.change_nodata(-9999)   # Use -9999 as nodata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span> <span class="o">=</span> <span class="n">nodatavalue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodatavalue</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Changing nodata to </span><span class="si">{</span><span class="n">nodatavalue</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Geoimage.change_names">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.change_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">change_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify the names of spectral bands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : dict</span>
<span class="sd">            Dictionary mapping band names to band indices</span>
<span class="sd">            (e.g., {&#39;R&#39;: 1, &#39;G&#39;: 2, &#39;B&#39;: 3, &#39;NIR&#39;: 4})</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Geoimage</span>
<span class="sd">            The method returns the object itself to allow method chaining</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of provided names doesn&#39;t match the number of bands</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; sentinel2_names = {&#39;B&#39;: 1, &#39;G&#39;: 2, &#39;R&#39;: 3, &#39;NIR&#39;: 4, &#39;SWIR1&#39;: 5, &#39;SWIR2&#39;: 6}</span>
<span class="sd">        &gt;&gt;&gt; image.change_names(sentinel2_names)</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # Shows updated band names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: the number of given names (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;the number of spectral bands (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">reorder_dict_by_values</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Changed band names&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="Geoimage.activate_history">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.activate_history">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">activate_history</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Activate history tracking for the image object.</span>

<span class="sd">        This method enables logging of operations performed on the image,</span>
<span class="sd">        which can be useful for tracking processing steps and debugging.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Geoimage</span>
<span class="sd">            The method returns the object itself to allow method chaining</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; image = Geoimage(&quot;landsat_image.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt; image.activate_history()</span>
<span class="sd">        &gt;&gt;&gt; image.resampling(30,inplace=True)  # This operation will be tracked in history</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # The history section will show the resampling operation</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        deactivate_history : Disable history tracking</span>
<span class="sd">        info : Display image information including history</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Geoimage.deactivate_history">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.deactivate_history">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">deactivate_history</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deactivate history tracking for the image object.</span>

<span class="sd">        This method disables logging of operations performed on the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Geoimage</span>
<span class="sd">            The method returns the object itself to allow method chaining</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; image.deactivate_history()</span>
<span class="sd">        &gt;&gt;&gt; image.resampling(15)  # This operation won&#39;t be tracked in history</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        activate_history : Enable history tracking</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Geoimage.copy">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a deep copy of the Geoimage object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage instance that is a complete copy of the current object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; original = Geoimage(&quot;landsat_image.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt; duplicate = original.copy()</span>
<span class="sd">        &gt;&gt;&gt; duplicate.resampling(15,inplace=True)  # This won&#39;t affect the original image</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method creates a completely independent copy. Changes to the copy</span>
<span class="sd">        won&#39;t affect the original image, and vice versa.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">georef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__georef</span>
        <span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="n">georef</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">history</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">activate_history</span><span class="p">()</span>
            <span class="c1"># Also copy history records if they exist</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__listhistory&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">:</span>
                <span class="n">im</span><span class="o">.</span><span class="n">__listhistory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">im</span></div>


<div class="viewcode-block" id="Geoimage.info">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print detailed information about the image.</span>

<span class="sd">        This method displays a comprehensive overview of the image&#39;s properties,</span>
<span class="sd">        including:</span>
<span class="sd">        - Dimensions (rows, columns, bands)</span>
<span class="sd">        - Spatial resolution</span>
<span class="sd">        - Geographic coordinates of the center</span>
<span class="sd">        - Projection system</span>
<span class="sd">        - Data type</span>
<span class="sd">        - Nodata value</span>
<span class="sd">        - Band names</span>
<span class="sd">        - Processing history (if history tracking is enabled)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; image = Geoimage(&quot;landsat_image.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt; image.info()</span>
<span class="sd">        &gt;&gt;&gt; - Size of the image:</span>
<span class="sd">        &gt;&gt;&gt;    - Rows (height): 1024</span>
<span class="sd">        &gt;&gt;&gt;    - Col (width): 1024</span>
<span class="sd">        &gt;&gt;&gt;    - Bands: 4</span>
<span class="sd">        &gt;&gt;&gt; - Spatial resolution: 30.0 meters / degree</span>
<span class="sd">        &gt;&gt;&gt; - Central point latitude - longitude coordinates: (36.12345, -118.67890)</span>
<span class="sd">        &gt;&gt;&gt; - Driver: GTiff</span>
<span class="sd">        &gt;&gt;&gt; - Data type: uint16</span>
<span class="sd">        &gt;&gt;&gt; - Projection system: EPSG:32611</span>
<span class="sd">        &gt;&gt;&gt; - Nodata: 0</span>
<span class="sd">        &gt;&gt;&gt; - Given names for spectral bands:</span>
<span class="sd">        &gt;&gt;&gt;    {&#39;B&#39;: 1, &#39;G&#39;: 2, &#39;R&#39;: 3, &#39;NIR&#39;: 4}</span>
<span class="sd">        &gt;&gt;&gt; --- History of modifications---</span>
<span class="sd">        &gt;&gt;&gt; [2023-09-15 10:30:22] - Read image landsat_image.tif</span>
<span class="sd">        &gt;&gt;&gt; [2023-09-15 10:31:45] - Apply resampling at 30.000000 meters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Size of the image:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   - Rows (height):&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   - Cols (width):&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   - Bands:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Spatial resolution:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="s1">&#39; meters / degree (depending on projection system)&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__georef</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">center_lat</span><span class="p">,</span> <span class="n">center_lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_latlon_coordinates</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;- Central point latitude - longitude coordinates: (</span><span class="si">{</span><span class="n">center_lat</span><span class="si">:</span><span class="s1">.8f</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">center_lon</span><span class="si">:</span><span class="s1">.8f</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Driver:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;driver&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Data type:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Projection system:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Nodata:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">- Given names for spectral bands: &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

<span class="c1">#        if self.__history is not False and hasattr(self, &#39;__listhistory&#39;) and self.__listhistory:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--- History of modifications---&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">history_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">history_entry</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.get_type">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_type">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the data type of the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The NumPy data type of the image (e.g., &#39;uint8&#39;, &#39;float32&#39;)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data_type = image.get_type()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image has data type: {data_type}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="Geoimage.get_spatial_resolution">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_spatial_resolution">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_spatial_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the spatial resolution of the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The spatial resolution in meters or degrees (depending on the projection)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; resolution = image.get_spatial_resolution()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image has {resolution} meter resolution&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Geoimage.get_latlon_coordinates">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_latlon_coordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_latlon_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the latitude and longitude coordinates of the central point of the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of float</span>
<span class="sd">            The (latitude, longitude) of the center of the image</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; lat, lon = image.get_latlon_coordinates()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image center is at latitude {lat}, longitude {lon}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel2latlon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">1</span><span class="p">]))</span></div>


<div class="viewcode-block" id="Geoimage.get_size">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the size (dimensions) of the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of int</span>
<span class="sd">            The (rows, columns) dimensions of the image</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rows, cols = image.get_size()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image has {rows} rows and {cols} columns&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Geoimage.get_nb_bands">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_nb_bands">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_nb_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of spectral bands in the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of bands</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; nb_bands = image.get_nb_bands()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image has {nb_bands} spectral bands&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="Geoimage.get_meta">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_meta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the metadata dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A copy of the rasterio metadata dictionary</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; metadata = image.get_meta()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image CRS: {metadata[&#39;crs&#39;]}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="Geoimage.get_nodata">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_nodata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_nodata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nodata value of the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float, int, or None</span>
<span class="sd">            The nodata value if it exists, otherwise None</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; nodata = image.get_nodata()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Nodata value: {nodata}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;nodata&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Geoimage.get_bounds">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_bounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the geographic bounds of the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rasterio.coords.BoundingBox</span>
<span class="sd">            The bounding box of the image (left, bottom, right, top)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; bounds = image.get_bounds()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image covers from ({bounds.left}, {bounds.bottom}) to ({bounds.right}, {bounds.top})&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">calculate_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.get_names">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_names">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the band names dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A copy of the dictionary mapping band names to band indices</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; names = image.get_names()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Red band is at index {names.get(&#39;R&#39;, &#39;unknown&#39;)}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="Geoimage.get_georef">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.get_georef">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_georef</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the image is georeferenced.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the image is georeferenced, False otherwise</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; is_georeferenced = image.get_georef()</span>
<span class="sd">        &gt;&gt;&gt; if not is_georeferenced:</span>
<span class="sd">        ...     print(&quot;Warning: Image is not georeferenced&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__georef</span></div>


<div class="viewcode-block" id="Geoimage.unique">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.unique">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the unique values in the image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of unique values found in the image</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; unique_values = image.unique()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image contains {len(unique_values)} unique values&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Values: {unique_values}&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is particularly useful for categorical data or classified images</span>
<span class="sd">        to see how many classes are present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span></div>



<div class="viewcode-block" id="Geoimage.abs">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.abs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the absolute value of the image data.</span>

<span class="sd">        This method modifies the image content directly by replacing all values</span>
<span class="sd">        with their absolute values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : str or None, optional</span>
<span class="sd">            Not used, kept for API consistency with other statistical methods.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do absolute value in place and return None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The absolute value image or None if `inplace=True`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; difference = image1 - image2  # May contain negative values</span>
<span class="sd">        &gt;&gt;&gt; diff_abs = difference.abs()  # Compute absolute values of `differences`</span>
<span class="sd">        &gt;&gt;&gt; difference.abs(inplace = True)  # Directly convert differences to absolute values</span>
<span class="sd">        &gt;&gt;&gt; difference.info()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Applied absolute value to image data&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__apply_abs</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_abs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image with the absolute values of this image.</span>

<span class="sd">        Unlike the `abs()` method, this doesn&#39;t modify the original image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : str or None, optional</span>
<span class="sd">            Not used, kept for API consistency with other statistical methods.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new image containing the absolute values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; difference = image1 - image2  # May contain negative values</span>
<span class="sd">        &gt;&gt;&gt; abs_difference = difference.apply_abs()  # New image with absolute values</span>
<span class="sd">        &gt;&gt;&gt; difference.info()  # Original still has negative values</span>
<span class="sd">        &gt;&gt;&gt; abs_difference.info()  # New image has only positive values</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        abs : Modify the image in-place with absolute values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">im</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">im</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created new image with absolute values&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">im</span>

<div class="viewcode-block" id="Geoimage.sum">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.sum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the sum of image values along a specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {&#39;band&#39;, &#39;row&#39;, &#39;col&#39;, None}, optional</span>
<span class="sd">            The axis along which to compute the sum:</span>
<span class="sd">            - &#39;band&#39;: Sum across spectral bands for each pixel</span>
<span class="sd">            - &#39;row&#39;: Sum across rows (lines) for each band and column</span>
<span class="sd">            - &#39;col&#39;: Sum across columns for each band and row</span>
<span class="sd">            - None: Sum of all values in the image</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            - If axis=None: A single value representing the sum of the entire image</span>
<span class="sd">            - If axis=&#39;band&#39;: Array with shape (nb_rows,nb_cols) containing  sums along bands</span>
<span class="sd">            - If axis=&#39;row&#39;: Array with shape (nb_bands,nb_cols) containing sums along rows</span>
<span class="sd">            - If axis=&#39;col&#39;: Array with shape (nb_bands,nb_rows) containing  sums along cols</span>
<span class="sd">            - If axis=&#39;pixel&#39;: Array with shape (nb_bands) containing  sums  along all pixels for each band</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an invalid axis is specified</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; total = image.sum()  # Sum of all pixel values</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Total pixel sum: {total}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; band_sums = image.sum(axis=&#39;pixel&#39;)  # Sum along all pixels for each band</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;band&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nansum(self.image, axis=(1, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;row&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nansum(self.image, axis=(0, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;col&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nansum(self.image, axis=(0, 1))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: axis &quot;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s1">&quot; undefined. Use &quot;band&quot;, &quot;row&quot;, &quot;col&quot;, or None.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.min">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.min">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the minimum value along a specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {&#39;band&#39;, &#39;row&#39;, &#39;col&#39;, None}, optional</span>
<span class="sd">            The axis along which to compute the minimum:</span>
<span class="sd">            - &#39;band&#39;: Minimum across spectral bands for each pixel</span>
<span class="sd">            - &#39;row&#39;: Minimum across rows (lines) for each band and column</span>
<span class="sd">            - &#39;col&#39;: Minimum across columns for each band and row</span>
<span class="sd">            - None: Global minimum of the entire image</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            - If axis=None: A single value representing the global minimum</span>
<span class="sd">            - If axis=&#39;band&#39;: Array with shape (nb_rows,nb_cols) containing  mins along bands</span>
<span class="sd">            - If axis=&#39;row&#39;: Array with shape (nb_bands,nb_cols) containing mins along rows</span>
<span class="sd">            - If axis=&#39;col&#39;: Array with shape (nb_bands,nb_rows) containing  mins along cols</span>
<span class="sd">            - If axis=&#39;pixel&#39;: Array with shape (nb_bands) containing  mins along all pixels for each band</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an invalid axis is specified</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; min_value = image.min()  # Global minimum value</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Minimum pixel value: {min_value}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; band_mins = image.min(axis=&#39;pixel&#39;)  # Minimum along all pixels for each band</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;band&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanmin(self.image, axis=(1, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;row&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanmin(self.image, axis=(0, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;col&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanmin(self.image, axis=(0, 1))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: axis &quot;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s1">&quot; undefined. Use &quot;band&quot;, &quot;row&quot;, &quot;col&quot;, or None.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.max">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.max">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the maximum value along a specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {&#39;band&#39;, &#39;row&#39;, &#39;col&#39;, None}, optional</span>
<span class="sd">            The axis along which to compute the maximum:</span>
<span class="sd">            - &#39;band&#39;: Maximum across spectral bands for each pixel</span>
<span class="sd">            - &#39;row&#39;: Maximum across rows (lines) for each band and column</span>
<span class="sd">            - &#39;col&#39;: Maximum across columns for each band and row</span>
<span class="sd">            - None: Global maximum of the entire image</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            - If axis=None: A single value representing the global maximum</span>
<span class="sd">            - If axis=&#39;band&#39;: Array with shape (nb_rows,nb_cols) containing  max along bands</span>
<span class="sd">            - If axis=&#39;row&#39;: Array with shape (nb_bands,nb_cols) containing max along rows</span>
<span class="sd">            - If axis=&#39;col&#39;: Array with shape (nb_bands,nb_rows) containing  max along cols</span>
<span class="sd">            - If axis=&#39;pixel&#39;: Array with shape (nb_bands) containing  maxs along all pixels for each band</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an invalid axis is specified</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; max_value = image.max()  # Global maximum value</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Maximum pixel value: {max_value}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; band_maxs = image.max(axis=&#39;pixel&#39;)  # Maximum along all pixels for each band</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;band&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanmax(self.image, axis=(1, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;row&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanmax(self.image, axis=(0, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;col&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanmax(self.image, axis=(0, 1))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: axis &quot;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s1">&quot; undefined. Use &quot;band&quot;, &quot;row&quot;, &quot;col&quot;, or None.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.mean">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.mean">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the mean value along a specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {&#39;band&#39;, &#39;row&#39;, &#39;col&#39;, None}, optional</span>
<span class="sd">            The axis along which to compute the mean:</span>
<span class="sd">            - &#39;band&#39;: Mean across spectral bands for each pixel</span>
<span class="sd">            - &#39;row&#39;: Mean across rows (lines) for each band and column</span>
<span class="sd">            - &#39;col&#39;: Mean across columns for each band and row</span>
<span class="sd">            - None: Global mean of the entire image</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            - If axis=None: A single value representing the global mean</span>
<span class="sd">            - If axis=&#39;band&#39;: Array with shape (nb_rows,nb_cols) containing  mean along bands</span>
<span class="sd">            - If axis=&#39;row&#39;: Array with shape (nb_bands,nb_cols) containing mean along rows</span>
<span class="sd">            - If axis=&#39;col&#39;: Array with shape (nb_bands,nb_rows) containing  mean along cols</span>
<span class="sd">            - If axis=&#39;pixel&#39;: Array with shape (nb_bands) containing  mean along all pixels for each band</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an invalid axis is specified</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mean_value = image.mean()  # Global mean value</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Mean pixel value: {mean_value}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; band_means = image.mean(axis=&#39;pixel&#39;)  # Mean along all pixels for each band</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method uses np.nanmean, which ignores NaN values in the calculation.</span>
<span class="sd">        If you have NaN values as nodata, they won&#39;t affect the mean calculation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;band&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanmean(self.image, axis=(1, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;row&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanmean(self.image, axis=(0, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;col&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanmean(self.image, axis=(0, 1))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: axis &quot;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s1">&quot; undefined. Use &quot;band&quot;, &quot;row&quot;, &quot;col&quot;, or None.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.std">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.std">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the standard deviation along a specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {&#39;band&#39;, &#39;row&#39;, &#39;col&#39;, None}, optional</span>
<span class="sd">            The axis along which to compute the standard deviation:</span>
<span class="sd">            - &#39;band&#39;: Std dev across spectral bands for each pixel</span>
<span class="sd">            - &#39;row&#39;: Std dev across rows (lines) for each band and column</span>
<span class="sd">            - &#39;col&#39;: Std dev across columns for each band and row</span>
<span class="sd">            - None: Global standard deviation of the entire image</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            - If axis=None: A single value representing the global std</span>
<span class="sd">            - If axis=&#39;band&#39;: Array with shape (nb_rows,nb_cols) containing  std along bands</span>
<span class="sd">            - If axis=&#39;row&#39;: Array with shape (nb_bands,nb_cols) containing std along rows</span>
<span class="sd">            - If axis=&#39;col&#39;: Array with shape (nb_bands,nb_rows) containing  std along cols</span>
<span class="sd">            - If axis=&#39;pixel&#39;: Array with shape (nb_bands) containing  std along all pixels for each band</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an invalid axis is specified</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; std_value = image.std()  # Global standard deviation</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Standard deviation of pixel values: {std_value}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; band_stds = image.std(axis=&#39;pixel&#39;)  # Standard deviation along all pixels for each band</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;band&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanstd(self.image, axis=(1, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;row&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanstd(self.image, axis=(0, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;col&#39;</span><span class="p">:</span>
            <span class="c1">#return np.nanstd(self.image, axis=(0, 1))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: axis &quot;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s1">&quot; undefined. Use &quot;band&quot;, &quot;row&quot;, &quot;col&quot;, or None.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.median">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.median">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the median value along a specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {&#39;band&#39;, &#39;row&#39;, &#39;col&#39;, None}, optional</span>
<span class="sd">            The axis along which to compute the median:</span>
<span class="sd">            - &#39;band&#39;: Median across spectral bands for each pixel</span>
<span class="sd">            - &#39;row&#39;: Median across rows (lines) for each band and column</span>
<span class="sd">            - &#39;col&#39;: Median across columns for each band and row</span>
<span class="sd">            - None: Global median of the entire image</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or numpy.ndarray</span>
<span class="sd">            - If axis=None: A single value representing the global median</span>
<span class="sd">            - If axis=&#39;band&#39;: Array with shape (nb_rows,nb_cols) containing  median along bands</span>
<span class="sd">            - If axis=&#39;row&#39;: Array with shape (nb_bands,nb_cols) containing median along rows</span>
<span class="sd">            - If axis=&#39;col&#39;: Array with shape (nb_bands,nb_rows) containing  median along cols</span>
<span class="sd">            - If axis=&#39;pixel&#39;: Array with shape (nb_bands) containing  median along all pixels for each band</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an invalid axis is specified</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; median_value = image.median()  # Global median value</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Median pixel value: {median_value}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; band_medians = image.median(axis=&#39;pixel&#39;)  # Median along all pixels for each band</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The median is the value separating the higher half from the lower half of the data.</span>
<span class="sd">        It&#39;s less sensitive to outliers than the mean, making it useful for images with</span>
<span class="sd">        extreme values or noise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;band&#39;</span><span class="p">:</span>
            <span class="c1">#return np.median(self.image, axis=(1, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;row&#39;</span><span class="p">:</span>
            <span class="c1">#return np.median(self.image, axis=(0, 2))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;col&#39;</span><span class="p">:</span>
            <span class="c1">#return np.median(self.image, axis=(0, 1))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: axis &quot;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s1">&quot; undefined. Use &quot;band&quot;, &quot;row&quot;, &quot;col&quot;, or None.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.replace_values">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.replace_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">replace_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_to_replace</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace all pixels that match a specified value across all bands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value_to_replace : float, int, or array-like</span>
<span class="sd">            The value(s) to search for in each pixel across all bands:</span>
<span class="sd">            - If a single value: Looks for pixels where all bands equal this value</span>
<span class="sd">            - If an array: Looks for pixels where each band matches the corresponding value</span>
<span class="sd">              in the array (must have the same length as the number of bands)</span>

<span class="sd">        new_value : float, int, or array-like</span>
<span class="sd">            The value(s) to assign to the matching pixels:</span>
<span class="sd">            - If a single value: Assigns this value to all bands of matching pixels</span>
<span class="sd">            - If an array: Assigns each value to the corresponding band of matching pixels</span>
<span class="sd">              (must have the same length as the number of bands)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Geoimage</span>
<span class="sd">            The modified image, allowing method chaining</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Replace all nodata (0) values with NaN</span>
<span class="sd">        &gt;&gt;&gt; image.replace_values(0, np.nan)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Replace a specific RGB color [255, 0, 0] with [0, 0, 0] (black)</span>
<span class="sd">        &gt;&gt;&gt; image.replace_values([255, 0, 0], [0, 0, 0])</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is useful for replacing nodata values, specific classes in</span>
<span class="sd">        a classification, or adjusting specific spectral signatures in an image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert single number to array with the same value for each band</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value_to_replace</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">value_to_replace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">value_to_replace</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_to_replace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value_to_replace</span><span class="p">)</span>

        <span class="c1"># Ensure new_value is a float array if it contains NaN</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">new_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Create a mask where all bands of a pixel match `value_to_replace`</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">==</span> <span class="n">value_to_replace</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span>
                      <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value_to_replace</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Replace matching pixels with `new_value` in all bands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Replaced values </span><span class="si">{</span><span class="n">value_to_replace</span><span class="si">}</span><span class="s1"> with </span><span class="si">{</span><span class="n">new_value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Geoimage.percentage_pixels">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.percentage_pixels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">percentage_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the percentage of pixels with a specified value across all bands.</span>

<span class="sd">        This method calculates what percentage of the total pixels have the specified</span>
<span class="sd">        value in all bands. It&#39;s particularly useful for calculating coverage of</span>
<span class="sd">        nodata values, specific land cover classes, or other categorical values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : int, float, list, or array-like, optional</span>
<span class="sd">            The value to check for in each band of a pixel:</span>
<span class="sd">            - If a single number: Checks for pixels where all bands equal this value</span>
<span class="sd">            - If a vector: Checks for pixels where each band matches the corresponding</span>
<span class="sd">              value in the vector (must have same length as number of bands)</span>
<span class="sd">            - If None: Uses the image&#39;s nodata value (default)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The percentage of pixels (from 0 to 100) where all bands have the specified value</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Calculate percentage of nodata pixels</span>
<span class="sd">        &gt;&gt;&gt; pct_nodata = image.percentage_pixels()  # Uses image&#39;s nodata value</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image contains {pct_nodata:.2f}% nodata pixels&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Calculate percentage of pixels with a specific class value</span>
<span class="sd">        &gt;&gt;&gt; pct_water = image.percentage_pixels(1)  # Assuming 1 = water class</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Water covers {pct_water:.2f}% of the image&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Calculate percentage of pixels with a specific spectral signature</span>
<span class="sd">        &gt;&gt;&gt; pct_rgb_black = image.percentage_pixels([0, 0, 0])  # RGB black pixels</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Black pixels (RGB=0,0,0) cover {pct_rgb_black:.2f}% of the image&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method handles both single values and vectors for the `value` parameter.</span>
<span class="sd">        The calculation correctly handles NaN values by considering NaN equal to NaN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no value specified, use the image&#39;s nodata value</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span>

        <span class="c1"># Access the full data array (shape: bands x rows x cols)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[:]</span>

        <span class="c1"># Convert `value` to a numpy array if it&#39;s a single number</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Create a mask where each pixel is True if all bands match `value`</span>
        <span class="n">matching_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">data</span> <span class="o">==</span> <span class="n">value</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">|</span>
                                 <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Calculate the percentage of pixels that meet this condition</span>
        <span class="n">percentage</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">matching_pixels</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">percentage</span></div>


<div class="viewcode-block" id="Geoimage.hist">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.hist">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display histograms of the image data.</span>

<span class="sd">        This method provides a flexible way to visualize the distribution of pixel values</span>
<span class="sd">        in one or more bands of the image. It supports various customization options for</span>
<span class="sd">        the histogram display.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : str, int, list, optional</span>
<span class="sd">            The bands to visualize. If not specified, all bands are included.</span>
<span class="sd">            This can be band names (e.g., [&quot;NIR&quot;, &quot;R&quot;, &quot;G&quot;]) or indices (e.g., [4, 3, 2]).</span>

<span class="sd">        superpose : bool, optional</span>
<span class="sd">            If True, all histograms are plotted on the same figure. If False (default),</span>
<span class="sd">            each band gets its own separate histogram figure.</span>

<span class="sd">        bins : int, optional</span>
<span class="sd">            The number of bins for computing the histogram. Default is 100.</span>

<span class="sd">        xmin : float, optional</span>
<span class="sd">            The minimum value to plot on the x-axis. Values lower than this won&#39;t be displayed.</span>

<span class="sd">        xmax : float, optional</span>
<span class="sd">            The maximum value to plot on the x-axis. Values higher than this won&#39;t be displayed.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            The title for the histogram figure.</span>

<span class="sd">        histtype : str, optional</span>
<span class="sd">            The type of histogram to draw. Default is &#39;stepfilled&#39;.</span>
<span class="sd">            Other options include &#39;bar&#39;, &#39;step&#39;, &#39;barstacked&#39;, etc.</span>

<span class="sd">        alpha : float, optional</span>
<span class="sd">            The transparency of the histogram bars (0.0 to 1.0). Default is 0.6.</span>

<span class="sd">        fig_size : tuple, optional</span>
<span class="sd">            The size of the figure in inches as (width, height). Default is DEF_FIG_SIZE.</span>

<span class="sd">        label : str or list of str, optional</span>
<span class="sd">            The labels for the histogram. If not provided, default labels will be created.</span>

<span class="sd">        **args : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to matplotlib&#39;s hist function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            This method displays the histogram(s) but doesn&#39;t return any values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Display histograms for all bands</span>
<span class="sd">        &gt;&gt;&gt; image.hist(bins=100)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Display histogram for a single band with customization</span>
<span class="sd">        &gt;&gt;&gt; image.hist(bands=&quot;NIR&quot;, bins=150, histtype=&#39;stepfilled&#39;,</span>
<span class="sd">        &gt;&gt;&gt;            title=&quot;NIR Band Distribution&quot;, xmin=0, xmax=10000)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Superpose histograms from multiple bands</span>
<span class="sd">        &gt;&gt;&gt; image.hist(bands=[&quot;NIR&quot;, &quot;R&quot;, &quot;G&quot;], bins=100, superpose=True,</span>
<span class="sd">        &gt;&gt;&gt;            alpha=0.7, fig_size=(10, 6))</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is based on rasterio&#39;s show_hist function and supports most</span>
<span class="sd">        of matplotlib&#39;s histogram customization options. It&#39;s useful for understanding</span>
<span class="sd">        the distribution of values in your image and identifying potential issues like</span>
<span class="sd">        saturation, quantization, or outliers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reset matplotlib settings to avoid interference</span>
        <span class="n">reset_matplotlib</span><span class="p">()</span>

        <span class="c1"># Make a copy of the image data for manipulation</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Handle xmin/xmax parameters to clip data range</span>
        <span class="k">if</span> <span class="s2">&quot;xmin&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;xmin&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;xmax&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;xmax&#39;</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;xmax&#39;</span><span class="p">]</span>

        <span class="c1"># Set default parameters if not provided</span>
        <span class="k">if</span> <span class="s2">&quot;bins&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>

        <span class="k">if</span> <span class="s2">&quot;histtype&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;histtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;stepfilled&#39;</span>

        <span class="k">if</span> <span class="s2">&quot;alpha&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.6</span>

        <span class="c1"># Extract superpose flag and figure size</span>
        <span class="k">if</span> <span class="s2">&quot;superpose&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">superpose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">superpose</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;superpose&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;superpose&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;fig_size&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">fig_size</span> <span class="o">=</span> <span class="n">DEF_FIG_SIZE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig_size</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;fig_size&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;fig_size&#39;</span><span class="p">]</span>

        <span class="c1"># Case 1: No specific bands requested (use all bands)</span>
        <span class="k">if</span> <span class="s2">&quot;bands&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">label_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="c1"># Create labels for each band</span>
            <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> - Band </span><span class="si">{</span><span class="n">label_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Band </span><span class="si">{</span><span class="n">label_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">])]</span>

            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>

            <span class="c1"># Either superpose all histograms or plot them separately</span>
            <span class="k">if</span> <span class="n">superpose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
                <span class="n">show_hist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                    <span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
                    <span class="n">show_hist</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># Case 2: Specific bands requested</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;bands&quot;</span><span class="p">])</span>

            <span class="c1"># Validate that requested bands exist</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
            <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: the requested bands (</span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s2">) are not all in the available bands (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

            <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bands&quot;</span><span class="p">]</span>

            <span class="c1"># For a single band</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                    <span class="n">args</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
                <span class="n">show_hist</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">bands</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># For multiple bands</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Handle labels for multiple bands</span>
                <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)):</span>
                            <span class="n">label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> - band </span><span class="si">{</span><span class="n">bands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)):</span>
                            <span class="n">label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)):</span>
                        <span class="n">label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Band </span><span class="si">{</span><span class="n">bands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="c1"># Either superpose histograms or plot them separately</span>
                <span class="k">if</span> <span class="n">superpose</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)):</span>
                        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
                        <span class="n">show_hist</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">bands</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)):</span>
                        <span class="n">args</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
                    <span class="n">band_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">band</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>
                    <span class="n">show_hist</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">band_indices</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.colorcomp">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.colorcomp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">colorcomp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fig_size</span><span class="o">=</span><span class="n">DEF_FIG_SIZE</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="s2">&quot;latlon&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and display a color composite image from selected bands.</span>

<span class="sd">        This method creates an RGB color composite by assigning three bands to the red,</span>
<span class="sd">        green, and blue channels. It&#39;s useful for creating false color compositions,</span>
<span class="sd">        natural color images, or any three-band visualization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : list of str, optional</span>
<span class="sd">            List of three band identifiers to use for the RGB composite (in order: R, G, B).</span>
<span class="sd">            Can be band names (e.g., [&quot;NIR&quot;, &quot;R&quot;, &quot;G&quot;]) or indices (e.g., [&quot;4&quot;, &quot;3&quot;, &quot;2&quot;]).</span>
<span class="sd">            If None, uses the first three bands in the image.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the color composite image. If empty, the image is not saved.</span>
<span class="sd">            Default is &#39;&#39;.</span>

<span class="sd">        percentile : int, optional</span>
<span class="sd">            Percentile value for contrast stretching (e.g., 2 for a 2-98% stretch).</span>
<span class="sd">            This enhances the visual contrast of the image.</span>
<span class="sd">            Default is 2.</span>

<span class="sd">        fig_size : tuple, optional</span>
<span class="sd">            Size of the figure in inches as (width, height).</span>
<span class="sd">            Default is DEF_FIG_SIZE.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            Title for the visualization.</span>
<span class="sd">            Default is &#39;&#39;.</span>

<span class="sd">        extent : {&#39;latlon&#39;, &#39;pixel&#39;, None}, optional</span>
<span class="sd">            Type of extent to use for the plot:</span>
<span class="sd">            - &#39;latlon&#39;: Use latitude/longitude coordinates (default)</span>
<span class="sd">            - &#39;pixel&#39;: Use pixel coordinates</span>
<span class="sd">            - None: Don&#39;t show coordinate axes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            This method displays and/or saves the color composite but doesn&#39;t return any values.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the image has only 2 bands, which is not enough for an RGB composite.</span>
<span class="sd">            If an invalid extent value is provided.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a natural color composite (for Landsat/Sentinel-2 style ordering)</span>
<span class="sd">        &gt;&gt;&gt; image.colorcomp(bands=[&quot;R&quot;, &quot;G&quot;, &quot;B&quot;])</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create a color-infrared composite (vegetation appears red)</span>
<span class="sd">        &gt;&gt;&gt; image.colorcomp(bands=[&quot;NIR&quot;, &quot;R&quot;, &quot;G&quot;], title=&quot;Color-Infrared Composite&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create and save a false color composite</span>
<span class="sd">        &gt;&gt;&gt; image.colorcomp(bands=[&quot;SWIR1&quot;, &quot;NIR&quot;, &quot;G&quot;], dest_name=&quot;false_color.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Change the contrast stretch</span>
<span class="sd">        &gt;&gt;&gt; image.colorcomp(bands=[&quot;R&quot;, &quot;G&quot;, &quot;B&quot;], percentile=5)  # More aggressive stretch</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Common band combinations for satellite imagery include:</span>
<span class="sd">        - Natural color: R, G, B (shows the scene as human eyes would see it)</span>
<span class="sd">        - Color-infrared: NIR, R, G (vegetation appears red, useful for vegetation analysis)</span>
<span class="sd">        - Agriculture: SWIR, NIR, B (highlights crop health and soil moisture)</span>
<span class="sd">        - Urban: SWIR, NIR, R (emphasizes urban areas and bare soil)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate extent parameter</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__extent_pixels</span>
        <span class="k">elif</span> <span class="n">extent</span> <span class="o">==</span> <span class="s1">&#39;latlon&#39;</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__extent_latlon</span>
        <span class="k">elif</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid extent value. Use &#39;pixel&#39;, &#39;latlon&#39;, or None.&quot;</span><span class="p">)</span>

        <span class="c1"># Handle single-band case (grayscale)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])),</span> <span class="n">percentile</span><span class="p">)</span>

            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="c1"># Save the image if requested</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">folder</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_name</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">.aux.xml&#39;</span><span class="p">)</span>

                <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dest_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">outds</span><span class="p">:</span>
                    <span class="n">outds</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])))</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Image saved in </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Handle two-band case (not enough for RGB)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error: unable to make a color composition with 2 channels. &quot;</span>
                           <span class="s2">&quot;Need at least 3 channels for RGB composition.&quot;</span><span class="p">)</span>

        <span class="c1"># Handle multi-band case (create RGB composite)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use first three bands if none specified</span>
            <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="mi">3</span><span class="p">]</span>

            <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

            <span class="c1"># Validate that requested bands exist</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
            <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: the requested bands (</span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s2">) are not all &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;in the available bands (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

            <span class="c1"># Create and display the color composite</span>
            <span class="n">colorcomp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">name_save</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span>
                      <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span>
                      <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span>
                      <span class="n">fig_size</span><span class="o">=</span><span class="n">fig_size</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span></div>



<div class="viewcode-block" id="Geoimage.convert_3bands">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.convert_3bands">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_3bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an image to a 3-band 8-bit RGB composite.</span>

<span class="sd">        This method creates a new Geoimage with exactly 3 bands in 8-bit format (0-255),</span>
<span class="sd">        suitable for standard RGB visualization or export to conventional image formats.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : list of str, optional</span>
<span class="sd">            List of three band identifiers to use for the RGB composite (in order: R, G, B).</span>
<span class="sd">            Can be band names (e.g., [&quot;NIR&quot;, &quot;R&quot;, &quot;G&quot;]) or indices (e.g., [&quot;4&quot;, &quot;3&quot;, &quot;2&quot;]).</span>
<span class="sd">            If None, uses the first three bands in the image.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the 3-band image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        percentile : int, optional</span>
<span class="sd">            Percentile value for contrast stretching (e.g., 2 for a 2-98% stretch).</span>
<span class="sd">            This enhances the visual contrast of the image.</span>
<span class="sd">            Default is 2.</span>

<span class="sd">        reformat_names : bool, optional</span>
<span class="sd">            Whether to reset band names to a simple numeric format (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).</span>
<span class="sd">            If False, keeps the original names of the selected bands.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with 3 bands (R, G, B) in 8-bit format.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a natural color composite</span>
<span class="sd">        &gt;&gt;&gt; rgb_image = image.convert_3bands(bands=[&quot;R&quot;, &quot;G&quot;, &quot;B&quot;])</span>
<span class="sd">        &gt;&gt;&gt; rgb_image.info()  # Should show 3 bands, uint8 data type</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create a false color composite with custom names</span>
<span class="sd">        &gt;&gt;&gt; false_color = image.convert_3bands(</span>
<span class="sd">        &gt;&gt;&gt;     bands=[&quot;SWIR&quot;, &quot;NIR&quot;, &quot;R&quot;], dest_name=&quot;false_color.tif&quot;,</span>
<span class="sd">        &gt;&gt;&gt;     reformat_names=True)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is useful for:</span>
<span class="sd">        - Creating standardized RGB exports</span>
<span class="sd">        - Preparing data for conventional image viewers that expect 3-band 8-bit data</span>
<span class="sd">        - Reducing file size by converting to 8-bit</span>
<span class="sd">        - Creating visually enhanced compositions with contrast stretching</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use first three bands if none specified</span>
        <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

        <span class="c1"># Validate that requested bands exist</span>
        <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
        <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: the requested bands (</span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s2">) are not all &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;in the available bands (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Validate band count</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: you need to provide exactly 3 spectral bands &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;(provided: </span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the requested bands</span>
        <span class="n">im_3bands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_bands</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the 8-bit RGB image</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">im_3bands</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">im_3bands</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">im</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">im_3bands</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">percentile</span><span class="p">)</span>
        <span class="n">im</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">im_3bands</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">percentile</span><span class="p">)</span>
        <span class="n">im</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">im_3bands</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">percentile</span><span class="p">)</span>

        <span class="c1"># Set band names</span>
        <span class="k">if</span> <span class="n">reformat_names</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">im_3bands</span><span class="o">.</span><span class="n">upload_image</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">im_3bands</span><span class="o">.</span><span class="n">get_names</span><span class="p">(),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im_3bands</span><span class="o">.</span><span class="n">upload_image</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im_3bands</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">im_3bands</span></div>


<div class="viewcode-block" id="Geoimage.plot_spectra">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.plot_spectra">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fig_size</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                     <span class="n">title_im</span><span class="o">=</span><span class="s2">&quot;Original image (click outside to stop)&quot;</span><span class="p">,</span>
                     <span class="n">title_spectra</span><span class="o">=</span><span class="s2">&quot;Spectra&quot;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Bands&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Value&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interactive tool to explore and plot spectral values from user-selected pixels.</span>

<span class="sd">        This method displays the image and allows the user to click on pixels to see</span>
<span class="sd">        their spectral values across all bands plotted as a line graph. Multiple pixels</span>
<span class="sd">        can be selected to compare different spectral signatures.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : list of str, optional</span>
<span class="sd">            List of three band identifiers to use for the background image display.</span>
<span class="sd">            If None, uses the first three bands in the image.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        fig_size : tuple, optional</span>
<span class="sd">            Size of the figure in inches as (width, height).</span>
<span class="sd">            Default is (15, 5).</span>

<span class="sd">        percentile : int, optional</span>
<span class="sd">            Percentile value for contrast stretching of the background image.</span>
<span class="sd">            Default is 2.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            Main title for the figure.</span>
<span class="sd">            Default is &#39;&#39;.</span>

<span class="sd">        title_im : str, optional</span>
<span class="sd">            Title for the image panel.</span>
<span class="sd">            Default is &quot;Original image (click outside to stop)&quot;.</span>

<span class="sd">        title_spectra : str, optional</span>
<span class="sd">            Title for the spectral plot panel.</span>
<span class="sd">            Default is &quot;Spectra&quot;.</span>

<span class="sd">        xlabel : str, optional</span>
<span class="sd">            X-axis label for the spectral plot.</span>
<span class="sd">            Default is &quot;Bands&quot;.</span>

<span class="sd">        ylabel : str, optional</span>
<span class="sd">            Y-axis label for the spectral plot.</span>
<span class="sd">            Default is &quot;Value&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - series : list of lists - Spectral values for each selected pixel</span>
<span class="sd">            - pixel_i : list of int - Row coordinates of selected pixels</span>
<span class="sd">            - pixel_j : list of int - Column coordinates of selected pixels</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Explore spectral signatures in the image</span>
<span class="sd">        &gt;&gt;&gt; spectra, rows, cols = image.plot_spectra()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Selected {len(spectra)} pixels&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Customize the display</span>
<span class="sd">        &gt;&gt;&gt; spectra, rows, cols = image.plot_spectra(</span>
<span class="sd">        &gt;&gt;&gt;     bands=[&quot;NIR&quot;, &quot;R&quot;, &quot;G&quot;],</span>
<span class="sd">        &gt;&gt;&gt;     title_im=&quot;Click on different vegetation types&quot;,</span>
<span class="sd">        &gt;&gt;&gt;     title_spectra=&quot;Vegetation Spectral Signatures&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To end pixel selection, click outside the image area or on the &quot;Finish&quot; button.</span>
<span class="sd">        This tool is particularly useful for:</span>
<span class="sd">        - Exploring spectral differences between land cover types</span>
<span class="sd">        - Identifying spectral anomalies</span>
<span class="sd">        - Training classification algorithms</span>
<span class="sd">        - Building spectral libraries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

        <span class="c1"># Get spectral values from clicked pixels</span>
        <span class="n">series</span><span class="p">,</span> <span class="n">pixel_i</span><span class="p">,</span> <span class="n">pixel_j</span> <span class="o">=</span> <span class="n">Visualizer</span><span class="o">.</span><span class="n">plot_spectra</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="n">bands</span><span class="p">,</span> <span class="n">fig_size</span><span class="o">=</span><span class="n">fig_size</span><span class="p">,</span>
            <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">title_im</span><span class="o">=</span><span class="n">title_im</span><span class="p">,</span> <span class="n">title_spectra</span><span class="o">=</span><span class="n">title_spectra</span><span class="p">,</span>
            <span class="n">xlabel</span><span class="o">=</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">ylabel</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">series</span><span class="p">,</span> <span class="n">pixel_i</span><span class="p">,</span> <span class="n">pixel_j</span></div>


<div class="viewcode-block" id="Geoimage.visu">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.visu">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fig_size</span><span class="o">=</span><span class="n">DEF_FIG_SIZE</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="s1">&#39;latlon&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visualize one or more bands of the image.</span>

<span class="sd">        This method provides a flexible way to display individual bands or multiple bands</span>
<span class="sd">        as separate figures. Unlike colorcomp, which creates RGB composites, this method</span>
<span class="sd">        displays each band in grayscale or with a specified colormap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : str, list of str, or None, optional</span>
<span class="sd">            The bands to visualize:</span>
<span class="sd">            - If None: Displays all bands separately</span>
<span class="sd">            - If a string: Displays a single specified band</span>
<span class="sd">            - If a list: Displays each specified band separately</span>
<span class="sd">            Default is None.</span>

<span class="sd">        title : str, optional</span>
<span class="sd">            Base title for the visualization. Band names will be appended.</span>
<span class="sd">            Default is &#39;&#39;.</span>

<span class="sd">        percentile : int, optional</span>
<span class="sd">            Percentile value for contrast stretching (e.g., 2 for a 2-98% stretch).</span>
<span class="sd">            Default is 2.</span>

<span class="sd">        fig_size : tuple, optional</span>
<span class="sd">            Size of the figure in inches as (width, height).</span>
<span class="sd">            Default is DEF_FIG_SIZE.</span>

<span class="sd">        cmap : str, optional</span>
<span class="sd">            Matplotlib colormap name to use for display.</span>
<span class="sd">            Examples: &#39;viridis&#39;, &#39;plasma&#39;, &#39;gray&#39;, &#39;RdYlGn&#39;</span>
<span class="sd">            Default is None (uses matplotlib default).</span>

<span class="sd">        colorbar : bool, optional</span>
<span class="sd">            Whether to display a colorbar next to each image.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        extent : {&#39;latlon&#39;, &#39;pixel&#39;, None}, optional</span>
<span class="sd">            Type of extent to use for the plot:</span>
<span class="sd">            - &#39;latlon&#39;: Use latitude/longitude coordinates (default)</span>
<span class="sd">            - &#39;pixel&#39;: Use pixel coordinates</span>
<span class="sd">            - None: Don&#39;t show coordinate axes</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Visualize all bands</span>
<span class="sd">        &gt;&gt;&gt; image.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Visualize a single band with a colormap and colorbar</span>
<span class="sd">        &gt;&gt;&gt; image.visu(&quot;NIR&quot;, cmap=&#39;plasma&#39;, colorbar=True, title=&quot;Near Infrared Band&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Visualize selected bands</span>
<span class="sd">        &gt;&gt;&gt; image.visu([&quot;Red&quot;, &quot;NIR&quot;, &quot;NDVI&quot;], fig_size=(10, 8))</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is useful for:</span>
<span class="sd">        - Examining individual spectral bands in detail</span>
<span class="sd">        - Comparing several derived indices side by side</span>
<span class="sd">        - Applying different colormaps to highlight specific features</span>
<span class="sd">        - Visualizing single-band thematic data (e.g., elevation, classification results)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate extent parameter</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__extent_pixels</span>
        <span class="k">elif</span> <span class="n">extent</span> <span class="o">==</span> <span class="s1">&#39;latlon&#39;</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__extent_latlon</span>
        <span class="k">elif</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid extent value. Use &#39;pixel&#39;, &#39;latlon&#39;, or None.&quot;</span><span class="p">)</span>

        <span class="c1"># Reset matplotlib settings</span>
        <span class="n">reset_matplotlib</span><span class="p">()</span>

        <span class="c1"># If no bands specified, use all bands</span>
        <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>

        <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

        <span class="c1"># Validate that requested bands exist</span>
        <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
        <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: the requested bands (</span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s2">) are not all &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;in the available bands (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Display a single band</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">get_percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">bands</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">percentile</span><span class="p">)</span>

            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">visu</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">colorbar</span><span class="p">:</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">visu</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">visu</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">colorbar</span><span class="p">:</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">visu</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Display multiple bands</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)):</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">get_percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">bands</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">percentile</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s1"> band </span><span class="si">{</span><span class="n">bands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">visu</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">colorbar</span><span class="p">:</span>
                        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">visu</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s1"> band </span><span class="si">{</span><span class="n">bands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">visu</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">colorbar</span><span class="p">:</span>
                        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">visu</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="Geoimage.numpy_channel_first">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.numpy_channel_first">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">numpy_channel_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract image data as a NumPy array in channel-first format.</span>

<span class="sd">        This method returns a NumPy array representation of the image data with bands</span>
<span class="sd">        as the first dimension (bands, rows, cols), which is the format used by rasterio.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : str, list of str, or None, optional</span>
<span class="sd">            The bands to include in the output:</span>
<span class="sd">            - If None: Returns all bands</span>
<span class="sd">            - If a string: Returns a single specified band</span>
<span class="sd">            - If a list: Returns the specified bands in the given order</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Image data as a NumPy array with shape (bands, rows, cols)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Get the complete image as a NumPy array</span>
<span class="sd">        &gt;&gt;&gt; array = image.numpy_channel_first()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Array shape: {array.shape}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Data type: {array.dtype}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Extract specific bands</span>
<span class="sd">        &gt;&gt;&gt; rgb_array = image.numpy_channel_first(bands=[&quot;R&quot;, &quot;G&quot;, &quot;B&quot;])</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;RGB array shape: {rgb_array.shape}&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This format (bands, rows, cols) is commonly used with rasterio and some other</span>
<span class="sd">        geospatial libraries. For libraries that expect channel-last format (like most</span>
<span class="sd">        image processing libraries), use numpy_channel_last() instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

            <span class="c1"># Validate that requested bands exist</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
            <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: the requested bands (</span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s2">) are not all &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;in the available bands (</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

            <span class="c1"># Get the indices of the requested bands</span>
            <span class="n">band_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">band</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>

            <span class="c1"># Return the selected bands</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">band_indices</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="Geoimage.numpy_channel_last">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.numpy_channel_last">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">numpy_channel_last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract image data as a NumPy array in channel-last format.</span>

<span class="sd">        This method returns a NumPy array representation of the image data with bands</span>
<span class="sd">        as the last dimension (rows, cols, bands), which is the format used by most</span>
<span class="sd">        image processing libraries and frameworks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : str, list of str, or None, optional</span>
<span class="sd">            The bands to include in the output:</span>
<span class="sd">            - If None: Returns all bands</span>
<span class="sd">            - If a string: Returns a single specified band</span>
<span class="sd">            - If a list: Returns the specified bands in the given order</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Image data as a NumPy array with shape (rows, cols, bands)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Get the complete image as a NumPy array</span>
<span class="sd">        &gt;&gt;&gt; array = image.numpy_channel_last()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Array shape: {array.shape}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Extract RGB bands for use with image processing libraries</span>
<span class="sd">        &gt;&gt;&gt; rgb = image.numpy_channel_last(bands=[&quot;R&quot;, &quot;G&quot;, &quot;B&quot;])</span>
<span class="sd">        &gt;&gt;&gt; import cv2</span>
<span class="sd">        &gt;&gt;&gt; blurred = cv2.GaussianBlur(rgb, (5, 5), 0)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This format (rows, cols, bands) is commonly used with image processing libraries</span>
<span class="sd">        like OpenCV, scikit-image, PIL, and deep learning frameworks. For libraries that</span>
<span class="sd">        expect channel-first format (like rasterio), use numpy_channel_first() instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rio2np</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

            <span class="c1"># Validate that requested bands exist</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
            <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: the requested bands (</span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s2">) are not all &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;in the available bands (</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

            <span class="c1"># Get the indices of the requested bands</span>
            <span class="n">band_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">band</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>

            <span class="c1"># Return the selected bands in channel-last format</span>
            <span class="k">return</span> <span class="n">rio2np</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">band_indices</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>


<div class="viewcode-block" id="Geoimage.numpy_table">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.numpy_table">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">numpy_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract image data as a 2D table of shape (pixels, bands).</span>

<span class="sd">        This method reshapes the image into a 2D table where each row represents a pixel</span>
<span class="sd">        and each column represents a band. This format is useful for machine learning,</span>
<span class="sd">        statistical analysis, or any operation that treats pixels as independent samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : str, list of str, or None, optional</span>
<span class="sd">            The bands to include in the output:</span>
<span class="sd">            - If None: Returns all bands</span>
<span class="sd">            - If a string: Returns a single specified band</span>
<span class="sd">            - If a list: Returns the specified bands in the given order</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Image data as a 2D table with shape (rows*cols, bands)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Convert the entire image to a table</span>
<span class="sd">        &gt;&gt;&gt; table = image.numpy_table()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Table shape: {table.shape}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Process specific bands as a table</span>
<span class="sd">        &gt;&gt;&gt; nir_red = image.numpy_table(bands=[&quot;NIR&quot;, &quot;R&quot;])</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Shape: {nir_red.shape}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ndvi = (nir_red[:, 0] - nir_red[:, 1]) / (nir_red[:, 0] + nir_red[:, 1])</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Mean NDVI: {ndvi.mean()}&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This format is particularly useful for:</span>
<span class="sd">        - Machine learning where each pixel is a sample and each band is a feature</span>
<span class="sd">        - Clustering algorithms like K-means</span>
<span class="sd">        - Statistical analysis across bands</span>
<span class="sd">        - Vectorized operations on pixels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">image2table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">image2table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numpy_channel_first</span><span class="p">(</span><span class="n">bands</span><span class="o">=</span><span class="n">bands</span><span class="p">))</span></div>


<div class="viewcode-block" id="Geoimage.image_from_table">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.image_from_table">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">image_from_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Geoimage from a 2D table of shape (pixels, bands).</span>

<span class="sd">        This method converts a 2D table where each row represents a pixel and each column</span>
<span class="sd">        represents a band into a new Geoimage object. It essentially performs the inverse</span>
<span class="sd">        operation of numpy_table().</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        table : numpy.ndarray</span>
<span class="sd">            The 2D table to convert, with shape (rows*cols, bands) or (rows*cols,) for a single band.</span>
<span class="sd">        names : dict, optional</span>
<span class="sd">            Dictionary mapping band names to band indices. If None, bands will be named</span>
<span class="sd">            sequentially (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, ...).</span>
<span class="sd">            Default is None.</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the new image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage created from the reshaped table</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of rows in the table doesn&#39;t match the dimensions of the original image</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a modified image from a processed table</span>
<span class="sd">        &gt;&gt;&gt; table = image.numpy_table()</span>
<span class="sd">        &gt;&gt;&gt; normalized = (table - table.mean()) / table.std()  # Standardize</span>
<span class="sd">        &gt;&gt;&gt; normalized_image = image.image_from_table(normalized)</span>
<span class="sd">        &gt;&gt;&gt; normalized_image.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Save the result</span>
<span class="sd">        &gt;&gt;&gt; table = image.numpy_table(bands=[&quot;NIR&quot;, &quot;R&quot;])</span>
<span class="sd">        &gt;&gt;&gt; ndvi = np.zeros((table.shape[0], 1))  # Create single-band output</span>
<span class="sd">        &gt;&gt;&gt; ndvi[:, 0] = (table[:, 0] - table[:, 1]) / (table[:, 0] + table[:, 1])</span>
<span class="sd">        &gt;&gt;&gt; ndvi_image = image.image_from_table(ndvi, names={&quot;NDVI&quot;: 1}, dest_name=&quot;ndvi.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The dimensions of the original image (rows, cols) are preserved, so the table must</span>
<span class="sd">        have exactly rows*cols rows. The number of bands can be different from the original image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: dimensions should match. Table has </span><span class="si">{</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> rows but &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;image size is (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;which corresponds to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> pixels&quot;</span><span class="p">)</span>

        <span class="c1"># Create metadata for the new image</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Reshape the table back into an image</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">table2image</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_size</span><span class="p">())</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">write_geoim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span>

        <span class="c1"># Create and return the new Geoimage</span>
        <span class="k">return</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.upload_table">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.upload_table">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">upload_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the image data with a 2D table of shape (pixels, bands).</span>

<span class="sd">        This method replaces the current image data with the content of a 2D table where</span>
<span class="sd">        each row represents a pixel and each column represents a band. The table is</span>
<span class="sd">        reshaped to match the image dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        table : numpy.ndarray</span>
<span class="sd">            The 2D table to upload, with shape (rows*cols, bands) or (rows*cols,) for a single band.</span>
<span class="sd">        names : dict, optional</span>
<span class="sd">            Dictionary mapping band names to band indices. If None, bands will be named</span>
<span class="sd">            sequentially (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, ...).</span>
<span class="sd">            Default is None.</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the updated image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Geoimage</span>
<span class="sd">            The updated image, allowing method chaining</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of rows in the table doesn&#39;t match the dimensions of the original image</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Update an image with processed data</span>
<span class="sd">        &gt;&gt;&gt; table = image.numpy_table()</span>
<span class="sd">        &gt;&gt;&gt; table = np.log(table + 1)  # Log transform</span>
<span class="sd">        &gt;&gt;&gt; image.upload_table(table)</span>
<span class="sd">        &gt;&gt;&gt; image.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Upload a single-band result and save</span>
<span class="sd">        &gt;&gt;&gt; ndvi_table = (nir - red) / (nir + red)  # Assuming nir and red are numpy arrays</span>
<span class="sd">        &gt;&gt;&gt; image.upload_table(ndvi_table, names={&quot;NDVI&quot;: 1}, dest_name=&quot;ndvi.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unlike image_from_table() which creates a new image, this method modifies the</span>
<span class="sd">        current image in place. The dimensions of the image (rows, cols) are preserved,</span>
<span class="sd">        but the number of bands can change if the table has a different number of columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: dimensions should match. Table has </span><span class="si">{</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> rows but &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;image size is (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;which corresponds to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> pixels&quot;</span><span class="p">)</span>

        <span class="c1"># Update metadata for the new band count</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Update data type</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>

        <span class="c1"># Reshape the table into an image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">table2image</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_size</span><span class="p">())</span>

        <span class="c1"># Update band names</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update_names</span><span class="p">()</span>

        <span class="c1"># Update derived attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">band_count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">band_count</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Uploaded new image from table with </span><span class="si">{</span><span class="n">band_count</span><span class="si">}</span><span class="s1"> bands&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Image saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Geoimage.upload_image">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.upload_image">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">upload_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the image data with a new image array.</span>

<span class="sd">        This method replaces the current image data with a new image array. The new image</span>
<span class="sd">        must have compatible dimensions with the current image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : numpy.ndarray</span>
<span class="sd">            The new image data to upload, with shape:</span>
<span class="sd">            - (bands, rows, cols) if channel_first=True</span>
<span class="sd">            - (rows, cols, bands) if channel_first=False</span>
<span class="sd">            - (rows, cols) for a single band</span>
<span class="sd">        names : dict, optional</span>
<span class="sd">            Dictionary mapping band names to band indices. If None, bands will be named</span>
<span class="sd"> sequentially (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, ...).</span>
<span class="sd">            Default is None.</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the updated image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        channel_first : bool, optional</span>
<span class="sd">            Whether the input image has channels in the first dimension (True) or the last</span>
<span class="sd">            dimension (False).</span>
<span class="sd">            Default is True.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, upload image in place and return None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The updated image or None if `inplace=True`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the spatial dimensions of the new image don&#39;t match the original image</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a new filtered image without modifying the original</span>
<span class="sd">        &gt;&gt;&gt; array = image.numpy_channel_first()</span>
<span class="sd">        &gt;&gt;&gt; filtered = apply_some_filter(array)  # Apply some processing</span>
<span class="sd">        &gt;&gt;&gt; filtered_image = image.upload_image(filtered)</span>
<span class="sd">        &gt;&gt;&gt; filtered_image.visu()</span>
<span class="sd">        &gt;&gt;&gt; image.visu()  # Original remains unchanged</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create a single-band image from NDVI calculation</span>
<span class="sd">        &gt;&gt;&gt; nir = image.numpy_channel_first(bands=[&quot;NIR&quot;])</span>
<span class="sd">        &gt;&gt;&gt; red = image.numpy_channel_first(bands=[&quot;Red&quot;])</span>
<span class="sd">        &gt;&gt;&gt; ndvi = (nir - red) / (nir + red)</span>
<span class="sd">        &gt;&gt;&gt; ndvi_image = image.upload_image(ndvi, names={&quot;NDVI&quot;: 1},</span>
<span class="sd">        &gt;&gt;&gt;                                dest_name=&quot;ndvi.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # Update an image with processed data</span>
<span class="sd">        &gt;&gt;&gt; array = image.numpy_channel_first()</span>
<span class="sd">        &gt;&gt;&gt; filtered = some_filter_function(array)  # Apply some processing</span>
<span class="sd">        &gt;&gt;&gt; image.upload_image(filtered, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; image.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Upload an image in channel-last format</span>
<span class="sd">        &gt;&gt;&gt; import cv2</span>
<span class="sd">        &gt;&gt;&gt; bgr = cv2.imread(&#39;rgb.jpg&#39;)  # OpenCV uses BGR order</span>
<span class="sd">        &gt;&gt;&gt; rgb = bgr[:, :, ::-1]  # Convert BGR to RGB</span>
<span class="sd">        &gt;&gt;&gt; image.upload_image(rgb, channel_first=False, dest_name=&quot;from_jpeg.tif&quot;, inplace=True))</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The spatial dimensions (rows, cols)</span>
<span class="sd">        must match the original image, but the number of bands can change.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Convert to channel-first format if needed</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">channel_first</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">np2rio</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

            <span class="c1"># Validate dimensions</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: dimensions should match. Provided image has shape &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">) but current image has shape &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

            <span class="c1"># Update metadata</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>

            <span class="c1"># Replace image data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>

            <span class="c1"># Update band names</span>
            <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">names</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__update_names</span><span class="p">()</span>

            <span class="c1"># Update derived attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

            <span class="c1"># Save if requested</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Uploaded new image with </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bands&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Image saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_upload_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="n">channel_first</span><span class="p">)</span></div>



    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_upload_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Geoimage with the provided image data.</span>

<span class="sd">        Unlike upload_image() which modifies the current image in place, this method</span>
<span class="sd">        creates a new Geoimage with the provided data, preserving the original.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : numpy.ndarray</span>
<span class="sd">            The image data to use, with shape:</span>
<span class="sd">            - (bands, rows, cols) if channel_first=True</span>
<span class="sd">            - (rows, cols, bands) if channel_first=False</span>
<span class="sd">            - (rows, cols) for a single band</span>
<span class="sd">        names : dict, optional</span>
<span class="sd">            Dictionary mapping band names to band indices. If None, bands will be named</span>
<span class="sd">            sequentially (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, ...).</span>
<span class="sd">            Default is None.</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the new image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        channel_first : bool, optional</span>
<span class="sd">            Whether the input image has channels in the first dimension (True) or the last</span>
<span class="sd">            dimension (False).</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with the provided data</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the spatial dimensions of the new image don&#39;t match the original image</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a new filtered image without modifying the original</span>
<span class="sd">        &gt;&gt;&gt; array = image.numpy_channel_first()</span>
<span class="sd">        &gt;&gt;&gt; filtered = apply_some_filter(array)  # Apply some processing</span>
<span class="sd">        &gt;&gt;&gt; filtered_image = image.apply_upload_image(filtered)</span>
<span class="sd">        &gt;&gt;&gt; filtered_image.visu()</span>
<span class="sd">        &gt;&gt;&gt; image.visu()  # Original remains unchanged</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create a single-band image from NDVI calculation</span>
<span class="sd">        &gt;&gt;&gt; nir = image.numpy_channel_first(bands=[&quot;NIR&quot;])</span>
<span class="sd">        &gt;&gt;&gt; red = image.numpy_channel_first(bands=[&quot;Red&quot;])</span>
<span class="sd">        &gt;&gt;&gt; ndvi = (nir - red) / (nir + red)</span>
<span class="sd">        &gt;&gt;&gt; ndvi_image = image.apply_upload_image(ndvi, names={&quot;NDVI&quot;: 1},</span>
<span class="sd">        &gt;&gt;&gt;                                      dest_name=&quot;ndvi.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method creates a new Geoimage object, preserving metadata like CRS,</span>
<span class="sd">        transform, and resolution from the original image. The spatial dimensions</span>
<span class="sd">        (rows, cols) must match the original image, but the number of bands can change.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert to channel-first format if needed</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">channel_first</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np2rio</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="c1"># Validate dimensions</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: dimensions should match. Provided image has shape &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">) but current image has shape &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Create metadata for the new image</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Create the new Geoimage</span>
        <span class="n">geoim</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geoim</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geoim</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">geoim</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created from existing image with </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bands&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">geoim</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">geoim</span>

<div class="viewcode-block" id="Geoimage.astype">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.astype">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the image data to a specified data type.</span>

<span class="sd">        This method changes the data type of the image pixels (e.g., from float32 to uint8).</span>
<span class="sd">        This can be useful for reducing memory usage or preparing data for specific operations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str or numpy.dtype</span>
<span class="sd">            The target data type (e.g., &#39;uint8&#39;, &#39;float32&#39;, &#39;int16&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Geoimage</span>
<span class="sd">            The modified image with the new data type, allowing method chaining</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Convert to 8-bit unsigned integer</span>
<span class="sd">        &gt;&gt;&gt; image.astype(&#39;uint8&#39;)</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # Should show dtype: uint8</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Convert to 32-bit floating point</span>
<span class="sd">        &gt;&gt;&gt; image.astype(&#39;float32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; image.visu()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Common data types for geospatial data:</span>
<span class="sd">        - uint8: 8-bit unsigned integer (0-255), useful for RGB display</span>
<span class="sd">        - int16: 16-bit signed integer (-32768 to 32767), common for satellite data</span>
<span class="sd">        - uint16: 16-bit unsigned integer (0-65535), common for satellite data</span>
<span class="sd">        - float32: 32-bit floating point, useful for continuous values and calculations</span>
<span class="sd">        - float64: 64-bit floating point, highest precision but more memory usage</span>

<span class="sd">        Warning: Converting to a smaller data type may result in loss of information</span>
<span class="sd">        or precision. For example, converting float32 to uint8.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npdtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">npdtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Changed data type to </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_resampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">final_resolution</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cubic_spline&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Geoimage with a different spatial resolution.</span>

<span class="sd">        This method creates a resampled copy of the current image with a new spatial</span>
<span class="sd">        resolution. Unlike resampling() which modifies the image in place, this method</span>
<span class="sd">        preserves the original image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        final_resolution : float</span>
<span class="sd">            The desired resolution in meters or degrees</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the resampled image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Resampling method to use. Options include:</span>
<span class="sd">            - &#39;cubic_spline&#39; (default): Cubic spline interpolation, best for continuous data</span>
<span class="sd">            - &#39;nearest&#39;: Nearest neighbor interpolation, best for categorical data</span>
<span class="sd">            - &#39;bilinear&#39;: Bilinear interpolation, good balance between quality and speed</span>
<span class="sd">            - &#39;cubic&#39;: Cubic interpolation, similar to cubic_spline but simpler</span>
<span class="sd">            - &#39;lanczos&#39;: Lanczos window filter, high quality for downsampling</span>
<span class="sd">            - &#39;average&#39;: Average of all contributing pixels, good for downsampling</span>
<span class="sd">            - &#39;mode&#39;: Most frequent value, good for categorical downsampling</span>
<span class="sd">            Default is &#39;cubic_spline&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with the resampled data</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a lower resolution version (e.g., from 10m to 30m)</span>
<span class="sd">        &gt;&gt;&gt; lowres = image.apply_resampling(30)</span>
<span class="sd">        &gt;&gt;&gt; lowres.info()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original resolution: {image.resolution}, New resolution: {lowres.resolution}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create a higher resolution version with nearest neighbor interpolation</span>
<span class="sd">        &gt;&gt;&gt; hires = image.apply_resampling(5, method=&#39;nearest&#39;, dest_name=&quot;hires.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt; hires.visu()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Downsampling (to a larger pixel size) reduces detail but can reduce noise</span>
<span class="sd">        - Upsampling (to a smaller pixel size) doesn&#39;t add new information, but can help</span>
<span class="sd">          with visual interpretation or alignment with other datasets</span>
<span class="sd">        - The resampling method matters:</span>
<span class="sd">          - For continuous data (elevation, reflectance), use &#39;cubic_spline&#39; or &#39;bilinear&#39;</span>
<span class="sd">          - For categorical data (land cover, classification), use &#39;nearest&#39; or &#39;mode&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">resampling</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">final_resolution</span><span class="p">,</span>
                              <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                              <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">)</span>

        <span class="c1"># Create a new Geoimage with the resampled data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by resampling to </span><span class="si">{</span><span class="n">final_resolution</span><span class="si">}</span><span class="s1"> meters/degrees &#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39;using </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1"> method&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deb_row_lon</span><span class="p">,</span> <span class="n">end_row_lon</span><span class="p">,</span> <span class="n">deb_col_lat</span><span class="p">,</span> <span class="n">end_col_lat</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Geoimage containing a cropped subset of this image.</span>

<span class="sd">        This method extracts a rectangular region of the image, defined either by pixel</span>
<span class="sd">        coordinates or by geographic coordinates, and returns it as a new Geoimage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deb_row_lon : int or float</span>
<span class="sd">            Start coordinate:</span>
<span class="sd">            - If pixel=True: Starting row (i) coordinate</span>
<span class="sd">            - If pixel=False: Starting longitude coordinate</span>
<span class="sd">        end_row_lon : int or float</span>
<span class="sd">            End coordinate:</span>
<span class="sd">            - If pixel=True: Ending row (i) coordinate</span>
<span class="sd">            - If pixel=False: Ending longitude coordinate</span>
<span class="sd">        deb_col_lat : int or float</span>
<span class="sd">            Start coordinate:</span>
<span class="sd">            - If pixel=True: Starting column (j) coordinate</span>
<span class="sd">            - If pixel=False: Starting latitude coordinate</span>
<span class="sd">        end_col_lat : int or float</span>
<span class="sd">            End coordinate:</span>
<span class="sd">            - If pixel=True: Ending column (j) coordinate</span>
<span class="sd">            - If pixel=False: Ending latitude coordinate</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the cropped image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        pixel : bool, optional</span>
<span class="sd">            If True, coordinates are interpreted as pixel indices (i, j).</span>
<span class="sd">            If False, coordinates are interpreted as geographic coordinates (lon, lat).</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage containing the cropped region</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Crop using pixel coordinates</span>
<span class="sd">        &gt;&gt;&gt; subset = image.apply_crop(100, 500, 200, 700)</span>
<span class="sd">        &gt;&gt;&gt; subset.info()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original size: {image.shape}, Cropped size: {subset.shape}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Crop using geographic coordinates</span>
<span class="sd">        &gt;&gt;&gt; lat1, lon1 = 42.5, -72.5  # Northwest corner</span>
<span class="sd">        &gt;&gt;&gt; lat2, lon2 = 42.4, -72.4  # Southeast corner</span>
<span class="sd">        &gt;&gt;&gt; region = image.apply_crop(lon1, lon2, lat1, lat2, pixel=False,</span>
<span class="sd">        &gt;&gt;&gt;                          dest_name=&quot;region.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt; region.visu()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - When using pixel coordinates, the format is (row_start, row_end, col_start, col_end)</span>
<span class="sd">        - When using geographic coordinates, the format is (lon_start, lon_end, lat_start, lat_end)</span>
<span class="sd">        - The cropped image inherits all metadata (projection, resolution, etc.) from the</span>
<span class="sd">          original, but with an updated transform to reflect the new spatial extent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert geographic coordinates to pixel coordinates if needed</span>
        <span class="k">if</span> <span class="n">pixel</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">row_deb</span><span class="p">,</span> <span class="n">col_deb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latlon2pixel</span><span class="p">(</span><span class="n">deb_col_lat</span><span class="p">,</span> <span class="n">deb_row_lon</span><span class="p">)</span>
            <span class="n">row_end</span><span class="p">,</span> <span class="n">col_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latlon2pixel</span><span class="p">(</span><span class="n">end_col_lat</span><span class="p">,</span> <span class="n">end_row_lon</span><span class="p">)</span>
            <span class="n">deb_row_lon_crop</span> <span class="o">=</span> <span class="n">row_deb</span>
            <span class="n">end_row_lon_crop</span> <span class="o">=</span> <span class="n">row_end</span>
            <span class="n">deb_col_lat_crop</span> <span class="o">=</span> <span class="n">col_deb</span>
            <span class="n">end_col_lat_crop</span> <span class="o">=</span> <span class="n">col_end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">deb_row_lon_crop</span> <span class="o">=</span> <span class="n">deb_row_lon</span>
            <span class="n">end_row_lon_crop</span> <span class="o">=</span> <span class="n">end_row_lon</span>
            <span class="n">deb_col_lat_crop</span> <span class="o">=</span> <span class="n">deb_col_lat</span>
            <span class="n">end_col_lat_crop</span> <span class="o">=</span> <span class="n">end_col_lat</span>

        <span class="c1"># Crop the image</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">crop_rio</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">deb_row_lon_crop</span><span class="p">,</span>
                             <span class="n">end_row_lon_crop</span><span class="p">,</span> <span class="n">deb_col_lat_crop</span><span class="p">,</span>
                             <span class="n">end_col_lat_crop</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span>
                             <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Create a new Geoimage with the cropped data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pixel</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by cropping from pixel coordinates &#39;</span>
                                            <span class="sa">f</span><span class="s1">&#39;rows </span><span class="si">{</span><span class="n">deb_row_lon</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">end_row_lon</span><span class="si">}</span><span class="s1">, cols </span><span class="si">{</span><span class="n">deb_col_lat</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">end_col_lat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by cropping from geographic coordinates &#39;</span>
                                            <span class="sa">f</span><span class="s1">&#39;lon </span><span class="si">{</span><span class="n">deb_row_lon</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">end_row_lon</span><span class="si">}</span><span class="s1">, lat </span><span class="si">{</span><span class="n">deb_col_lat</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">end_col_lat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Geoimage.reproject">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.reproject">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reproject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;EPSG:3857&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reproject the image to a different coordinate reference system (CRS).</span>

<span class="sd">        This method transforms the image to a new projection system, which</span>
<span class="sd">        changes how the image&#39;s coordinates are interpreted. This can be useful for</span>
<span class="sd">        aligning data from different sources or preparing data for specific analyses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        projection : str, optional</span>
<span class="sd">            The target projection as an EPSG code or PROJ string.</span>
<span class="sd">            Examples:</span>

<span class="sd">            - &quot;EPSG:4326&quot;: WGS84 geographic (lat/lon)</span>

<span class="sd">            - &quot;EPSG:3857&quot;: Web Mercator (used by web maps)</span>

<span class="sd">            - &quot;EPSG:32619&quot;: UTM Zone 19N</span>
<span class="sd">            Default is &quot;EPSG:3857&quot; (Web Mercator).</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do reprojection in place and return None.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the reprojected image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The reprojected image or None if `inplace=True`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Reproject to WGS84 (latitude/longitude)</span>
<span class="sd">        &gt;&gt;&gt; image_reprojected = image.reproject(&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; image_reprojected.info()  # Shows new projection</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Reproject to UTM Zone 17N and save</span>
<span class="sd">        &gt;&gt;&gt; image_reprojected = image.reproject(&quot;EPSG:32617&quot;, dest_name=&quot;utm.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Reproject to WGS84 (latitude/longitude) and modify inplace the image</span>
<span class="sd">        &gt;&gt;&gt; image.reproject(&quot;EPSG:4326&quot;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # Shows new projection</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Reproject to UTM Zone 17N and save</span>
<span class="sd">        &gt;&gt;&gt; image.reproject(&quot;EPSG:32617&quot;, dest_name=&quot;utm.tif&quot;, inplace=True)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Reprojection can change the pixel values due to resampling</span>
<span class="sd">        - The dimensions of the image will typically change during reprojection</span>
<span class="sd">        - Common projection systems include:</span>
<span class="sd">        - EPSG:4326 - WGS84 geographic coordinates (latitude/longitude)</span>
<span class="sd">        - EPSG:3857 - Web Mercator (used by Google Maps, OpenStreetMap)</span>
<span class="sd">        - EPSG:326xx - UTM Zone xx North (projected coordinate system)</span>
<span class="sd">        - EPSG:327xx - UTM Zone xx South (projected coordinate system)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Get the source CRS and transform</span>
            <span class="n">src_crs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span>
            <span class="n">src_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span>

            <span class="c1"># Calculate the transform, width, and height for the new projection</span>
            <span class="n">transform</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">calculate_default_transform</span><span class="p">(</span>
                <span class="n">src_crs</span><span class="p">,</span> <span class="n">projection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">())</span>

            <span class="c1"># Update metadata with new projection info</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">projection</span><span class="p">,</span>
                <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span><span class="p">,</span>
                <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span>
            <span class="p">})</span>

            <span class="c1"># Create new array for reprojected data</span>
            <span class="n">reprojected_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">])</span>

            <span class="c1"># Reproject each band</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">reproject</span><span class="p">(</span>
                    <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                    <span class="n">destination</span><span class="o">=</span><span class="n">reprojected_img</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                    <span class="n">src_transform</span><span class="o">=</span><span class="n">src_transform</span><span class="p">,</span>
                    <span class="n">src_crs</span><span class="o">=</span><span class="n">src_crs</span><span class="p">,</span>
                    <span class="n">dst_transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                    <span class="n">dst_crs</span><span class="o">=</span><span class="n">projection</span><span class="p">,</span>
                    <span class="n">resampling</span><span class="o">=</span><span class="n">Resampling</span><span class="o">.</span><span class="n">nearest</span>
                <span class="p">)</span>

            <span class="c1"># Update image data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">reprojected_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Update derived attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Reprojected to </span><span class="si">{</span><span class="n">projection</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_reproject</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_reproject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;EPSG:3857&quot;</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Geoimage with a different coordinate reference system (CRS).</span>

<span class="sd">        This method creates a new Geoimage with the specified projection, preserving</span>
<span class="sd">        the original image. Unlike reproject() which modifies the image in place,</span>
<span class="sd">        this method returns a new image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        projection : str, optional</span>
<span class="sd">            The target projection as an EPSG code or PROJ string.</span>
<span class="sd">            Examples:</span>
<span class="sd">            - &quot;EPSG:4326&quot;: WGS84 geographic (lat/lon)</span>
<span class="sd">            - &quot;EPSG:3857&quot;: Web Mercator (used by web maps)</span>
<span class="sd">            - &quot;EPSG:32619&quot;: UTM Zone 19N</span>
<span class="sd">            Default is &quot;EPSG:3857&quot; (Web Mercator).</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the reprojected image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with the reprojected data</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a WGS84 version without modifying the original</span>
<span class="sd">        &gt;&gt;&gt; wgs84 = image.apply_reproject(&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; wgs84.info()</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # Original remains unchanged</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create a UTM version and save it</span>
<span class="sd">        &gt;&gt;&gt; utm = image.apply_reproject(&quot;EPSG:32617&quot;, dest_name=&quot;utm.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Reprojection can change the pixel values due to resampling</span>
<span class="sd">        - The dimensions of the image will typically change during reprojection</span>
<span class="sd">        - This method is useful when you need both the original projection and a reprojected version for different analyses</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a copy of metadata</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Get the source CRS and transform</span>
        <span class="n">src_crs</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;crs&#39;</span><span class="p">]</span>
        <span class="n">src_transform</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span>

        <span class="c1"># Calculate the transform, width, and height for the new projection</span>
        <span class="n">transform</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">calculate_default_transform</span><span class="p">(</span>
            <span class="n">src_crs</span><span class="p">,</span> <span class="n">projection</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">],</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">())</span>

        <span class="c1"># Update metadata with new projection info</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">projection</span><span class="p">,</span>
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span><span class="p">,</span>
            <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
            <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span>
        <span class="p">})</span>

        <span class="c1"># Create new array for reprojected data</span>
        <span class="n">reprojected_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">])</span>

        <span class="c1"># Reproject each band</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">reproject</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                <span class="n">destination</span><span class="o">=</span><span class="n">reprojected_img</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                <span class="n">src_transform</span><span class="o">=</span><span class="n">src_transform</span><span class="p">,</span>
                <span class="n">src_crs</span><span class="o">=</span><span class="n">src_crs</span><span class="p">,</span>
                <span class="n">dst_transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                <span class="n">dst_crs</span><span class="o">=</span><span class="n">projection</span><span class="p">,</span>
                <span class="n">resampling</span><span class="o">=</span><span class="n">Resampling</span><span class="o">.</span><span class="n">nearest</span>
            <span class="p">)</span>

        <span class="c1"># Create a new Geoimage with the reprojected data</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">reprojected_img</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by reprojecting to </span><span class="si">{</span><span class="n">projection</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Geoimage.latlon2pixel">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.latlon2pixel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">latlon2pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord_lat</span><span class="p">,</span> <span class="n">coord_lon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert geographic coordinates (latitude, longitude) to pixel coordinates.</span>

<span class="sd">        This method transforms a point defined by its latitude and longitude to</span>
<span class="sd">        the corresponding pixel location (row, col) in the image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord_lat : float</span>
<span class="sd">            Latitude of the point</span>
<span class="sd">        coord_lon : float</span>
<span class="sd">            Longitude of the point</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of int</span>
<span class="sd">            The pixel coordinates as (row, col) or (i, j)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Convert a geographic location to pixel coordinates</span>
<span class="sd">        &gt;&gt;&gt; latitude, longitude = 42.36, -71.06  # Boston, MA</span>
<span class="sd">        &gt;&gt;&gt; row, col = image.latlon2pixel(latitude, longitude)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;This location is at pixel ({row}, {col})&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Check if a specific location is within the image extent</span>
<span class="sd">        &gt;&gt;&gt; row, col = image.latlon2pixel(latitude, longitude)</span>
<span class="sd">        &gt;&gt;&gt; in_bounds = (0 &lt;= row &lt; image.shape[0]) and (0 &lt;= col &lt; image.shape[1])</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Location is within image: {in_bounds}&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The image must be georeferenced (have valid CRS and transform)</span>
<span class="sd">        - If the point is outside the image extent, the function will still return pixel coordinates, but they may be outside the valid image dimensions</span>
<span class="sd">        - Row (i) corresponds to the vertical position (along latitude)</span>
<span class="sd">        - Column (j) corresponds to the horizontal position (along longitude)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">latlon_to_pixels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span> <span class="n">coord_lat</span><span class="p">,</span> <span class="n">coord_lon</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.pixel2latlon">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.pixel2latlon">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pixel2latlon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert pixel coordinates to geographic coordinates (latitude, longitude).</span>

<span class="sd">        This method transforms a pixel location (row, col) in the image to the</span>
<span class="sd">        corresponding point defined by its latitude and longitude.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Row index (vertical position) in the image</span>
<span class="sd">        j : int</span>
<span class="sd">            Column index (horizontal position) in the image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of float</span>
<span class="sd">            The geographic coordinates as (latitude, longitude)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Convert pixel coordinates to geographic location</span>
<span class="sd">        &gt;&gt;&gt; row, col = 500, 700</span>
<span class="sd">        &gt;&gt;&gt; latitude, longitude = image.pixel2latlon(row, col)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Pixel ({row}, {col}) is at lat/lon: ({latitude}, {longitude})&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Find coordinates of image corners</span>
<span class="sd">        &gt;&gt;&gt; nw_lat, nw_lon = image.pixel2latlon(0, 0)  # Northwest corner</span>
<span class="sd">        &gt;&gt;&gt; se_lat, se_lon = image.pixel2latlon(image.shape[0]-1, image.shape[1]-1)  # Southeast</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Image covers from ({nw_lat}, {nw_lon}) to ({se_lat}, {se_lon})&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The image must be georeferenced (have valid CRS and transform)</span>
<span class="sd">        - Pixel coordinates typically start at (0, 0) in the upper-left corner of the image</span>
<span class="sd">        - For most projections, latitude increases going north and longitude increases going east</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pixels_to_latlon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.save">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.save">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the image to a GeoTIFF or JPEG2000 file.</span>

<span class="sd">        This method writes the image data and all its metadata (projection, transform,</span>
<span class="sd">        etc.) to a georeferenced file that can be read by most geospatial software.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dest_name : str</span>
<span class="sd">            Path to save the image. File format is determined by the extension:</span>
<span class="sd">            - .tif or .tiff: GeoTIFF format</span>
<span class="sd">            - .jp2: JPEG2000 format</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Save as GeoTIFF</span>
<span class="sd">        &gt;&gt;&gt; image.save(&quot;output.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Save as JPEG2000</span>
<span class="sd">        &gt;&gt;&gt; image.save(&quot;output.jp2&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - GeoTIFF (.tif) is the most widely supported format</span>
<span class="sd">        - JPEG2000 (.jp2) offers compression and is good for large images</span>
<span class="sd">        - The saved file will include all metadata (projection, transform, etc.)</span>
<span class="sd">        - To save a subset of bands, first use select_bands() to create a new image with only the desired bands, then save that image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Save the image to the specified file</span>
        <span class="n">write_geoim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Saved to </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_extract_from_shapefile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_shp</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;code&#39;</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Geoimage containing only data from areas matching a shapefile attribute value.</span>

<span class="sd">        This method extracts data from the image only where the shapefile has polygons</span>
<span class="sd">        with the specified attribute value. All other areas are set to nodata_value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name_shp : str</span>
<span class="sd">            Path to the shapefile (.shp) to use for extraction</span>
<span class="sd">        value : int or float</span>
<span class="sd">            The attribute value to extract (e.g., extract only areas with code=3)</span>
<span class="sd">        attribute : str, optional</span>
<span class="sd">            The name of the attribute field in the shapefile to use.</span>
<span class="sd">            Default is &#39;code&#39;.</span>
<span class="sd">        nodata_value : int or float, optional</span>
<span class="sd">            Value to assign to areas outside the extracted regions.</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        keep_size : bool, optional</span>
<span class="sd">            If True, output has the same dimensions as input.</span>
<span class="sd">            If False, output is cropped to the shapefile extent.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage containing only the extracted regions</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Extract forest areas (assuming forest has code 3 in the shapefile)</span>
<span class="sd">        &gt;&gt;&gt; forest = image.apply_extract_from_shapefile(&quot;landcover.shp&quot;, 3)</span>
<span class="sd">        &gt;&gt;&gt; forest.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Extract urban areas and keep the original image size</span>
<span class="sd">        &gt;&gt;&gt; urban = image.apply_extract_from_shapefile(</span>
<span class="sd">        &gt;&gt;&gt;     &quot;landcover.shp&quot;, 1, attribute=&quot;class&quot;,</span>
<span class="sd">        &gt;&gt;&gt;     nodata_value=-9999, keep_size=True)</span>
<span class="sd">        &gt;&gt;&gt; urban.save(&quot;urban_areas.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The shapefile must be in the same CRS as the image, or reprojection may be necessary</span>
<span class="sd">        - Use shpfiles.get_shapefile_attributes(name_shp) to view available attributes</span>
<span class="sd">        - This method is useful for:</span>
<span class="sd">        - Extracting specific land cover types from an image</span>
<span class="sd">        - Creating masks for different geographic regions</span>
<span class="sd">        - Focusing analysis on specific areas of interest</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read shapefile with matching resolution</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="n">shpfiles</span><span class="o">.</span><span class="n">shp2geoim</span><span class="p">(</span><span class="n">name_shp</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">)</span>

        <span class="c1"># Ensure images have matching dimensions</span>
        <span class="n">shp</span><span class="p">,</span> <span class="n">imc</span> <span class="o">=</span> <span class="n">extract_common_areas</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">shp</span><span class="p">,</span> <span class="n">imc</span> <span class="o">=</span> <span class="n">ajust_sizes</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">imc</span><span class="p">)</span>

        <span class="c1"># Create extraction mask from shapefile</span>
        <span class="n">image_nodata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">imc</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">nodata_value</span><span class="p">)</span>
        <span class="n">mask_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">shp</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">image_nodata</span><span class="p">[:,</span> <span class="n">mask_condition</span><span class="p">]</span> <span class="o">=</span> <span class="n">imc</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="n">mask_condition</span><span class="p">]</span>

        <span class="c1"># Create new image with extracted data</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">imc</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodata_value</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">image_nodata</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># Optionally extend to original image size</span>
        <span class="k">if</span> <span class="n">keep_size</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extend_common_areas</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="Geoimage.extract_from_shapefile">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.extract_from_shapefile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_from_shapefile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_shp</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;code&#39;</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract data from areas matching a shapefile attribute value.</span>

<span class="sd">        This method modifies the image by keeping only data where the shapefile has</span>
<span class="sd">        polygons with the specified attribute value. All other areas are set to nodata_value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name_shp : str</span>
<span class="sd">            Path to the shapefile (.shp) to use for extraction</span>
<span class="sd">        value : int or float</span>
<span class="sd">            The attribute value to extract (e.g., extract only areas with code=3)</span>
<span class="sd">        attribute : str, optional</span>
<span class="sd">            The name of the attribute field in the shapefile to use.</span>
<span class="sd">            Default is &#39;code&#39;.</span>
<span class="sd">        nodata_value : int or float, optional</span>
<span class="sd">            Value to assign to areas outside the extracted regions.</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do the extraction in place</span>
<span class="sd">        keep_size : bool, optional</span>
<span class="sd">            If True, output has the same dimensions as input.</span>
<span class="sd">            If False, output is cropped to the shapefile extent.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The image containing only the extracted regions or None if `inplace = True`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Extract only forest areas (assuming forest has code 3 in the shapefile)</span>
<span class="sd">        &gt;&gt;&gt; image_forest = image.extract_from_shapefile(&quot;landcover.shp&quot;, 3)</span>
<span class="sd">        &gt;&gt;&gt; image.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Keep only urban areas and preserve the original image size</span>
<span class="sd">        &gt;&gt;&gt; image.extract_from_shapefile(</span>
<span class="sd">        &gt;&gt;&gt;      &quot;landcover.shp&quot;, 1, attribute=&quot;class&quot;,</span>
<span class="sd">        &gt;&gt;&gt;      nodata_value=-9999, keep_size=True, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; image.save(&quot;urban_areas.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The shapefile must be in the same CRS as the image, or reprojection may be necessary</span>
<span class="sd">        - Use shpfiles.get_shapefile_attributes(name_shp) to view available attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Read shapefile with matching resolution</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="n">shpfiles</span><span class="o">.</span><span class="n">shp2geoim</span><span class="p">(</span><span class="n">name_shp</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">)</span>

            <span class="c1"># Ensure images have matching dimensions</span>
            <span class="n">shp</span><span class="p">,</span> <span class="n">imc</span> <span class="o">=</span> <span class="n">extract_common_areas</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">shp</span><span class="p">,</span> <span class="n">imc</span> <span class="o">=</span> <span class="n">ajust_sizes</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">imc</span><span class="p">)</span>

            <span class="c1"># Create extraction mask from shapefile</span>
            <span class="n">image_nodata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">imc</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">nodata_value</span><span class="p">)</span>
            <span class="n">mask_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">shp</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">image_nodata</span><span class="p">[:,</span> <span class="n">mask_condition</span><span class="p">]</span> <span class="o">=</span> <span class="n">imc</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="n">mask_condition</span><span class="p">]</span>

            <span class="c1"># Update metadata and image data</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">imc</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodata_value</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">image_nodata</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="c1"># Optionally extend to original image size</span>
            <span class="k">if</span> <span class="n">keep_size</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extend_common_areas</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">)</span>

            <span class="c1"># Update current image with extracted data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">nb_bands</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">resolution</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Extracted regions with </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1"> &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;from shapefile </span><span class="si">{</span><span class="n">name_shp</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_extract_from_shapefile</span><span class="p">(</span><span class="n">name_shp</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="n">keep_size</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_extract_from_shapeimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shp</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;code&#39;</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Geoimage containing only data from areas matching a shape image value.</span>

<span class="sd">        This method extracts data from the image only where another Geoimage (typically</span>
<span class="sd">        created from a shapefile) has the specified value. All other areas are set to nodata_value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shp : Geoimage</span>
<span class="sd">            A Geoimage object, typically created from a shapefile, to use for extraction</span>
<span class="sd">        value : int or float</span>
<span class="sd">            The pixel value to extract from (e.g., extract only where shp has value 3)</span>
<span class="sd">        attribute : str, optional</span>
<span class="sd">            Not used for this method, kept for API consistency with apply_extract_from_shapefile.</span>
<span class="sd">            Default is &#39;code&#39;.</span>
<span class="sd">        nodata_value : int or float, optional</span>
<span class="sd">            Value to assign to areas outside the extracted regions.</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        keep_size : bool, optional</span>
<span class="sd">            If True, output has the same dimensions as input.</span>
<span class="sd">            If False, output is cropped to the shape image extent.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage containing only the extracted regions</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # First create a shape image from a shapefile</span>
<span class="sd">        &gt;&gt;&gt; landcover = shpfiles.shp2geoim(&quot;landcover.shp&quot;, attribute=&quot;class&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Extract forest areas (assuming forest has value 3)</span>
<span class="sd">        &gt;&gt;&gt; forest = image.apply_extract_from_shapeimage(landcover, 3)</span>
<span class="sd">        &gt;&gt;&gt; forest.visu()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The shape image must have the same CRS as the target image, or it will be resampled to match</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Resample shape image if needed</span>
        <span class="k">if</span> <span class="n">shp</span><span class="o">.</span><span class="n">resolution</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">:</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="n">shp</span><span class="o">.</span><span class="n">resampling</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)</span>

        <span class="c1"># Ensure images have matching dimensions</span>
        <span class="n">shp</span><span class="p">,</span> <span class="n">imc</span> <span class="o">=</span> <span class="n">extract_common_areas</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">shp</span><span class="p">,</span> <span class="n">imc</span> <span class="o">=</span> <span class="n">ajust_sizes</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">imc</span><span class="p">)</span>

        <span class="c1"># Create extraction mask from shape image</span>
        <span class="n">image_nodata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">imc</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">nodata_value</span><span class="p">)</span>
        <span class="n">mask_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">shp</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">image_nodata</span><span class="p">[:,</span> <span class="n">mask_condition</span><span class="p">]</span> <span class="o">=</span> <span class="n">imc</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="n">mask_condition</span><span class="p">]</span>

        <span class="c1"># Create new image with extracted data</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">imc</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodata_value</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">image_nodata</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># Optionally extend to original image size</span>
        <span class="k">if</span> <span class="n">keep_size</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extend_common_areas</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="Geoimage.extract_from_shapeimage">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.extract_from_shapeimage">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_from_shapeimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shp</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;code&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract data from areas matching a shape image value.</span>

<span class="sd">        This method modifies the image by keeping only data where another Geoimage</span>
<span class="sd">        (typically created from a shapefile) has the specified value. All other areas</span>
<span class="sd">        are set to nodata_value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shp : Geoimage</span>
<span class="sd">            A Geoimage object, typically created from a shapefile, to use for extraction</span>
<span class="sd">        value : int or float</span>
<span class="sd">            The pixel value to extract from (e.g., extract only where shp has value 3)</span>
<span class="sd">        attribute : str, optional</span>
<span class="sd">            Not used for this method, kept for API consistency with extract_from_shapefile.</span>
<span class="sd">            Default is &#39;code&#39;.</span>
<span class="sd">        nodata_value : int or float, optional</span>
<span class="sd">            Value to assign to areas outside the extracted regions.</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do the extraction in place</span>
<span class="sd">        keep_size : bool, optional</span>
<span class="sd">            If True, output has the same dimensions as input.</span>
<span class="sd">            If False, output is cropped to the shape image extent.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage containing only the extracted regions or None if `inplace=True`</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # First create a shape image from a shapefile</span>
<span class="sd">        &gt;&gt;&gt; landcover = shpfiles.shp2geoim(&quot;landcover.shp&quot;, attribute=&quot;class&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Keep only forest areas (assuming forest has value 3)</span>
<span class="sd">        &gt;&gt;&gt; image_forest = image.extract_from_shapeimage(landcover, 3)</span>
<span class="sd">        &gt;&gt;&gt; image_forest.visu()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The shape image must have the same CRS as the target image,or it will be resampled to match</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Resample shape image if needed</span>
            <span class="k">if</span> <span class="n">shp</span><span class="o">.</span><span class="n">resolution</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">:</span>
                <span class="n">shp</span> <span class="o">=</span> <span class="n">shp</span><span class="o">.</span><span class="n">resampling</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)</span>

            <span class="c1"># Ensure images have matching dimensions</span>
            <span class="n">shp</span><span class="p">,</span> <span class="n">imc</span> <span class="o">=</span> <span class="n">extract_common_areas</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">shp</span><span class="p">,</span> <span class="n">imc</span> <span class="o">=</span> <span class="n">ajust_sizes</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">imc</span><span class="p">)</span>

            <span class="c1"># Create extraction mask from shape image</span>
            <span class="n">image_nodata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">imc</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">nodata_value</span><span class="p">)</span>
            <span class="n">mask_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">shp</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">image_nodata</span><span class="p">[:,</span> <span class="n">mask_condition</span><span class="p">]</span> <span class="o">=</span> <span class="n">imc</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="n">mask_condition</span><span class="p">]</span>

            <span class="c1"># Create image with extracted data</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">imc</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;nodata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodata_value</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">image_nodata</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="c1"># Optionally extend to original image size</span>
            <span class="k">if</span> <span class="n">keep_size</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extend_common_areas</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">)</span>

            <span class="c1"># Update current image with extracted data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">nb_bands</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">resolution</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Extracted regions with value=</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1"> &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;from shape image&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_extract_from_shapeimage</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="n">keep_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.kmeans">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.kmeans">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">kmeans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">RANDOM_STATE</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">standardization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nb_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform K-means clustering on the image data.</span>

<span class="sd">        This method performs an unsupervised classification using K-means clustering,</span>
<span class="sd">        which groups pixels with similar spectral characteristics into a specified</span>
<span class="sd">        number of clusters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_clusters : int, optional</span>
<span class="sd">            Number of clusters (classes) to create.</span>
<span class="sd">            Default is 4.</span>
<span class="sd">        bands : list of str or None, optional</span>
<span class="sd">            List of bands to use for clustering. If None, all bands are used.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        random_state : int or None, optional</span>
<span class="sd">            Random seed for reproducible results. If None, results may vary between runs.</span>
<span class="sd">            Default is RANDOM_STATE (defined globally).</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the clustered image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        standardization : bool, optional</span>
<span class="sd">            Whether to standardize bands before clustering (recommended).</span>
<span class="sd">            Default is True.</span>
<span class="sd">        nb_points : int or None, optional</span>
<span class="sd">            Number of random points to sample for training the model. If None,</span>
<span class="sd">            all valid pixels are used (may be slow for large images).</span>
<span class="sd">            Default is 1000.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage containing the cluster IDs (0 to n_clusters-1)</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing (kmeans_model, scaler) for reusing the model on other images</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Basic K-means clustering with 5 clusters</span>
<span class="sd">        &gt;&gt;&gt; classified, model = image.kmeans(n_clusters=5)</span>
<span class="sd">        &gt;&gt;&gt; classified.visu(colorbar=True, cmap=&#39;viridis&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Cluster using only specific bands and save result</span>
<span class="sd">        &gt;&gt;&gt; classified, model = image.kmeans(</span>
<span class="sd">        &gt;&gt;&gt;      n_clusters=3, bands=[&quot;NIR&quot;, &quot;Red&quot;, &quot;Green&quot;],</span>
<span class="sd">        &gt;&gt;&gt;      dest_name=&quot;clusters.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Apply same model to another image</span>
<span class="sd">        &gt;&gt;&gt; other_classified = other_image.apply_ML_model(model)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Standardization is recommended, especially when bands have different ranges</span>
<span class="sd">        - The returned model can be used with apply_ML_model() on other images</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize random number generator</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Extract image data as table</span>
        <span class="n">tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">(</span><span class="n">bands</span><span class="o">=</span><span class="n">bands</span><span class="p">)</span>

        <span class="c1"># Remove nodata pixels</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tab</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tab</span> <span class="o">=</span> <span class="n">tab</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Sample points if requested (for speed)</span>
        <span class="k">if</span> <span class="n">nb_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nb_points</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">tab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">nb_points</span><span class="p">,))</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">tab</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Standardize data if requested</span>
        <span class="k">if</span> <span class="n">standardization</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Apply K-means clustering</span>
        <span class="n">kmean_model</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">kmean_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>

        <span class="c1"># Apply the model to create classified image</span>
        <span class="n">im_classif</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_ML_model</span><span class="p">((</span><span class="n">kmean_model</span><span class="p">,</span> <span class="n">scaler</span><span class="p">),</span> <span class="n">bands</span><span class="o">=</span><span class="n">bands</span><span class="p">)</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">im_classif</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">im_classif</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">im_classif</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created using K-means clustering &#39;</span><span class="sa">f</span><span class="s1">&#39;with </span><span class="si">{</span><span class="n">n_clusters</span><span class="si">}</span><span class="s1"> clusters&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">im_classif</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Using bands: </span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">im_classif</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">im_classif</span><span class="p">,</span> <span class="p">(</span><span class="n">kmean_model</span><span class="p">,</span> <span class="n">scaler</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.apply_ML_model">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.apply_ML_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_ML_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a pre-trained machine learning model to the image.</span>

<span class="sd">        This method applies a machine learning model (such as one created by kmeans())</span>
<span class="sd">        to the image data, creating a new classified or transformed image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : tuple</span>
<span class="sd">            A tuple containing (ml_model, scaler) where:</span>
<span class="sd">            - ml_model: A trained scikit-learn model with a predict() method</span>
<span class="sd">            - scaler: The scaler used for standardization (or None if not used)</span>
<span class="sd">        bands : list of str or None, optional</span>
<span class="sd">            List of bands to use as input for the model. If None, all bands are used.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage containing the model output</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Train a model on one image and apply to another</span>
<span class="sd">        &gt;&gt;&gt; classified, model = reference_image.kmeans(n_clusters=5)</span>
<span class="sd">        &gt;&gt;&gt; new_classified = target_image.apply_ML_model(model)</span>
<span class="sd">        &gt;&gt;&gt; new_classified.visu(colorbar=True, cmap=&#39;viridis&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Train on specific bands and apply to the same bands</span>
<span class="sd">        &gt;&gt;&gt; _, model = image.kmeans(bands=[&quot;NIR&quot;, &quot;Red&quot;], n_clusters=3)</span>
<span class="sd">        &gt;&gt;&gt; result = image.apply_ML_model(model, bands=[&quot;NIR&quot;, &quot;Red&quot;])</span>
<span class="sd">        &gt;&gt;&gt; result.save(&quot;classified.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The model must have been trained on data with the same structure as what it&#39;s being applied to (e.g., same number of bands)</span>
<span class="sd">        - If a scaler was used during training, it will be applied before prediction</span>
<span class="sd">        - This method is useful for:</span>
<span class="sd">        - Applying a classification model to new images</span>
<span class="sd">        - Ensuring consistent classification across multiple scenes</span>
<span class="sd">        - Time-series analysis with consistent classification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract model and scaler from tuple</span>
        <span class="n">ml_model</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Convert image data to table format</span>
        <span class="n">tab_ori</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">(</span><span class="n">bands</span><span class="o">=</span><span class="n">bands</span><span class="p">)</span>

        <span class="c1"># Apply scaling if a scaler was provided</span>
        <span class="k">if</span> <span class="n">scaler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tab_ori</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">tab_ori</span><span class="p">)</span>

        <span class="c1"># Apply the model to get predictions</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">ml_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">tab_ori</span><span class="p">)</span>

        <span class="c1"># Reshape predictions back to image format</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">table2image</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Create metadata for output image</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Set band count based on output shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Update data type</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">outputs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_str</span>

        <span class="c1"># Create and return new Geoimage with model outputs</span>
        <span class="n">im_classif</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">outputs</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">,</span> <span class="n">history</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">im_classif</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">model_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">ml_model</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">im_classif</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created using ML model: </span><span class="si">{</span><span class="n">model_type</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">im_classif</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Using bands: </span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">im_classif</span></div>


<div class="viewcode-block" id="Geoimage.adapt">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.adapt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">adapt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imt</span><span class="p">,</span> <span class="n">tab_source</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nb</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">reg_e</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">1e0</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust spectral characteristics to match a target image.</span>

<span class="sd">        This method adapts the spectral characteristics of the current image to match</span>
<span class="sd">        those of a target image using optimal transport methods. This is useful for</span>
<span class="sd">        harmonizing images from different sensors or acquisitions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        imt : Geoimage or numpy.ndarray</span>
<span class="sd">            Target image serving as a reference for spectral adjustment,</span>
<span class="sd">            or a NumPy array of shape (N, bands) containing N spectral samples.</span>
<span class="sd">        tab_source : numpy.ndarray, optional</span>
<span class="sd">            Required if `imt` is a NumPy array. Must be an array of shape (M, bands)</span>
<span class="sd">            containing spectral samples from the source image.</span>
<span class="sd">        nb : int, optional</span>
<span class="sd">            Number of random samples used to train the transport model.</span>
<span class="sd">            Default is 1000.</span>
<span class="sd">        mapping : str, optional</span>
<span class="sd">            Optimal transport method to use:</span>
<span class="sd">            - &#39;emd&#39;: Earth Mover&#39;s Distance (simplest)</span>
<span class="sd">            - &#39;sinkhorn&#39;: Sinkhorn transport with regularization (balanced)</span>
<span class="sd">            - &#39;mappingtransport&#39;: Mapping-based transport (flexible)</span>
<span class="sd">            - &#39;gaussian&#39;: Transport with Gaussian assumptions (default, robust)</span>
<span class="sd">            Default is &#39;gaussian&#39;.</span>
<span class="sd">        reg_e : float, optional</span>
<span class="sd">            Regularization parameter for Sinkhorn transport.</span>
<span class="sd">            Default is 1e-1.</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">            Regularization parameter for mapping-based methods.</span>
<span class="sd">            Default is 1e0.</span>
<span class="sd">        eta : float, optional</span>
<span class="sd">            Learning rate for mapping-based transport methods.</span>
<span class="sd">            Default is 1e-2.</span>
<span class="sd">        bias : bool, optional</span>
<span class="sd">            Whether to add a bias term to the transport model.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        max_iter : int, optional</span>
<span class="sd">            Maximum number of iterations for iterative transport methods.</span>
<span class="sd">            Default is 20.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            Whether to display progress information.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        sigma : float, optional</span>
<span class="sd">            Standard deviation used for Gaussian transport methods.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do the adaptation in place and return None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The image with adapted spectral characteristics or None if `inplace=True`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Basic spectral adaptation</span>
<span class="sd">        &gt;&gt;&gt; image_adapt = image1.adapt(image2)</span>
<span class="sd">        &gt;&gt;&gt; image_adapt.visu()  # Now spectrally similar to image2</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Use specific transport method</span>
<span class="sd">        &gt;&gt;&gt; image_adapt = image1.adapt(image2, mapping=&#39;sinkhorn&#39;, reg_e=0.01)</span>
<span class="sd">        &gt;&gt;&gt; image_adapt.save(&quot;adapted_image.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Adaptation using sample arrays</span>
<span class="sd">        &gt;&gt;&gt; adapted_image = image1.adapt(tab_target, tab_source = tab_source, mapping=&#39;sinkhorn&#39;, reg_e=0.01)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Basic spectral adaptation and modify inplace the image</span>
<span class="sd">        &gt;&gt;&gt; image1.adapt(image2, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; image1.visu()  # Now spectrally similar to image2</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is useful for:</span>
<span class="sd">            - Harmonizing multi-sensor data</span>
<span class="sd">            - Matching images acquired under different conditions</span>
<span class="sd">            - Preparing time-series data for consistent analysis</span>
<span class="sd">        - Different mapping methods have different characteristics:</span>
<span class="sd">            - &#39;emd&#39;: Most accurate but slowest</span>
<span class="sd">            - &#39;sinkhorn&#39;: Good balance between accuracy and speed</span>
<span class="sd">            - &#39;mappingtransport&#39;: Flexible and can handle complex transformations</span>
<span class="sd">            - &#39;gaussian&#39;: Fastest and works well for most cases</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">InferenceTools</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imt</span><span class="p">,</span> <span class="n">tab_source</span><span class="o">=</span><span class="n">tab_source</span><span class="p">,</span> <span class="n">nb</span><span class="o">=</span><span class="n">nb</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">reg_e</span><span class="o">=</span><span class="n">reg_e</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Adapted spectral characteristics to match target image &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;using </span><span class="si">{</span><span class="n">mapping</span><span class="si">}</span><span class="s1"> method&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_adapt</span><span class="p">(</span><span class="n">imt</span><span class="p">,</span> <span class="n">tab_source</span> <span class="o">=</span> <span class="n">tab_source</span><span class="p">,</span> <span class="n">nb</span><span class="o">=</span><span class="n">nb</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">reg_e</span><span class="o">=</span><span class="n">reg_e</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_adapt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imt</span><span class="p">,</span> <span class="n">tab_source</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nb</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">reg_e</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">1e0</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image with spectral characteristics matching a target image.</span>

<span class="sd">        This method creates a new image by adapting the spectral characteristics of</span>
<span class="sd">        the current image to match those of a target image using optimal transport methods.</span>
<span class="sd">        Unlike adapt() which modifies the image in place, this preserves the original.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        imt : Geoimage or numpy.ndarray</span>
<span class="sd">            Target image serving as a reference for spectral adjustment,</span>
<span class="sd">            or a NumPy array of shape (N, bands) containing N spectral samples.</span>
<span class="sd">        tab_source : numpy.ndarray, optional</span>
<span class="sd">            Required if `imt` is a NumPy array. Must be an array of shape (M, bands)</span>
<span class="sd">            containing spectral samples from the source image.</span>
<span class="sd">        nb : int, optional</span>
<span class="sd">            Number of random samples used to train the transport model.</span>
<span class="sd">            Default is 1000.</span>
<span class="sd">        mapping : str, optional</span>
<span class="sd">            Optimal transport method to use:</span>
<span class="sd">            - &#39;emd&#39;: Earth Mover&#39;s Distance (simplest)</span>
<span class="sd">            - &#39;sinkhorn&#39;: Sinkhorn transport with regularization (balanced)</span>
<span class="sd">            - &#39;mappingtransport&#39;: Mapping-based transport (flexible)</span>
<span class="sd">            - &#39;gaussian&#39;: Transport with Gaussian assumptions (default, robust)</span>
<span class="sd">            Default is &#39;gaussian&#39;.</span>
<span class="sd">        reg_e : float, optional</span>
<span class="sd">            Regularization parameter for Sinkhorn transport.</span>
<span class="sd">            Default is 1e-1.</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">            Regularization parameter for mapping-based methods.</span>
<span class="sd">            Default is 1e0.</span>
<span class="sd">        eta : float, optional</span>
<span class="sd">            Learning rate for mapping-based transport methods.</span>
<span class="sd">            Default is 1e-2.</span>
<span class="sd">        bias : bool, optional</span>
<span class="sd">            Whether to add a bias term to the transport model.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        max_iter : int, optional</span>
<span class="sd">            Maximum number of iterations for iterative transport methods.</span>
<span class="sd">            Default is 20.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            Whether to display progress information.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        sigma : float, optional</span>
<span class="sd">            Standard deviation used for Gaussian transport methods.</span>
<span class="sd">            Default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new image with adapted spectral characteristics</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create spectrally adapted version of an image</span>
<span class="sd">        &gt;&gt;&gt; adapted = image1.__apply_adapt(image2)</span>
<span class="sd">        &gt;&gt;&gt; adapted.visu()  # Spectrally similar to image2</span>
<span class="sd">        &gt;&gt;&gt; image1.visu()   # Original remains unchanged</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Adaptation using sample arrays</span>
<span class="sd">        &gt;&gt;&gt; adapted_image = image1.__apply_adapt(tab_target, tab_source = tab_source, mapping=&#39;sinkhorn&#39;, reg_e=0.01)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Save the result with specific transport method</span>
<span class="sd">        &gt;&gt;&gt; adapted = image1.apply_adapt(</span>
<span class="sd">        &gt;&gt;&gt;      image2, mapping=&#39;sinkhorn&#39;, reg_e=0.01)</span>
<span class="sd">        &gt;&gt;&gt; adapted.save(&quot;adapted_image.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is useful for:</span>
<span class="sd">            - Harmonizing multi-sensor data while preserving originals</span>
<span class="sd">            - Testing different adaptation parameters</span>
<span class="sd">            - Creating multiple adaptations for comparison</span>
<span class="sd">        - For details on the different mapping methods, see the adapt() method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">InferenceTools</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imt</span><span class="p">,</span> <span class="n">tab_source</span> <span class="o">=</span> <span class="n">tab_source</span><span class="p">,</span> <span class="n">nb</span><span class="o">=</span><span class="n">nb</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">reg_e</span><span class="o">=</span><span class="n">reg_e</span><span class="p">,</span>
                        <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by adapting spectral characteristics &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;to match target image using </span><span class="si">{</span><span class="n">mapping</span><span class="si">}</span><span class="s1"> method&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>



<div class="viewcode-block" id="Geoimage.fuse_dempster_shafer_2">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.fuse_dempster_shafer_2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fuse_dempster_shafer_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">images</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fuse the 3 band image (associated with mass functions) from multiple</span>
<span class="sd">        sources using Dempster-Shafer theory with two hypotheses: A and B.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *images : Geoimage</span>
<span class="sd">            Each input is a 3-band Geoimage.</span>

<span class="sd">            - Band 1: mass function m(A)</span>

<span class="sd">            - Band 2: mass function m(B)</span>

<span class="sd">            - Band 3: mass function m(A  B)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with 3 bands containing the fused mass functions:</span>
<span class="sd">            m(A), m(B), and m(A  B).</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with 1 band containing the conflict values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; fused, conflict = im1.fuse_dempster_shafer_2(im2)</span>
<span class="sd">        &gt;&gt;&gt; fused, conflict = im1.fuse_dempster_shafer_2(im1, im2, im3, im4)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">InferenceTools</span><span class="o">.</span><span class="n">fuse_dempster_shafer_2hypotheses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">images</span><span class="p">)</span></div>



    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_adapt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imt</span><span class="p">,</span> <span class="n">tab_source</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nb</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">reg_e</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">1e0</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image with spectral characteristics matching a target image.</span>

<span class="sd">        This method creates a new image by adapting the spectral characteristics of</span>
<span class="sd">        the current image to match those of a target image using optimal transport methods.</span>
<span class="sd">        Unlike adapt() which modifies the image in place, this preserves the original.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        imt : Geoimage or numpy.ndarray</span>
<span class="sd">            Target image serving as a reference for spectral adjustment,</span>
<span class="sd">            or a NumPy array of shape (N, bands) containing N spectral samples.</span>
<span class="sd">        tab_source : numpy.ndarray, optional</span>
<span class="sd">            Required if `imt` is a NumPy array. Must be an array of shape (M, bands)</span>
<span class="sd">            containing spectral samples from the source image.</span>
<span class="sd">        nb : int, optional</span>
<span class="sd">            Number of random samples used to train the transport model.</span>
<span class="sd">            Default is 1000.</span>
<span class="sd">        mapping : str, optional</span>
<span class="sd">            Optimal transport method to use:</span>
<span class="sd">            - &#39;emd&#39;: Earth Mover&#39;s Distance (simplest)</span>
<span class="sd">            - &#39;sinkhorn&#39;: Sinkhorn transport with regularization (balanced)</span>
<span class="sd">            - &#39;mappingtransport&#39;: Mapping-based transport (flexible)</span>
<span class="sd">            - &#39;gaussian&#39;: Transport with Gaussian assumptions (default, robust)</span>
<span class="sd">            Default is &#39;gaussian&#39;.</span>
<span class="sd">        reg_e : float, optional</span>
<span class="sd">            Regularization parameter for Sinkhorn transport.</span>
<span class="sd">            Default is 1e-1.</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">            Regularization parameter for mapping-based methods.</span>
<span class="sd">            Default is 1e0.</span>
<span class="sd">        eta : float, optional</span>
<span class="sd">            Learning rate for mapping-based transport methods.</span>
<span class="sd">            Default is 1e-2.</span>
<span class="sd">        bias : bool, optional</span>
<span class="sd">            Whether to add a bias term to the transport model.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        max_iter : int, optional</span>
<span class="sd">            Maximum number of iterations for iterative transport methods.</span>
<span class="sd">            Default is 20.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            Whether to display progress information.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        sigma : float, optional</span>
<span class="sd">            Standard deviation used for Gaussian transport methods.</span>
<span class="sd">            Default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new image with adapted spectral characteristics</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create spectrally adapted version of an image</span>
<span class="sd">        &gt;&gt;&gt; adapted = image1.__apply_adapt(image2)</span>
<span class="sd">        &gt;&gt;&gt; adapted.visu()  # Spectrally similar to image2</span>
<span class="sd">        &gt;&gt;&gt; image1.visu()   # Original remains unchanged</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Adaptation using sample arrays</span>
<span class="sd">        &gt;&gt;&gt; adapted_image = image1.__apply_adapt(tab_target, tab_source = tab_source, mapping=&#39;sinkhorn&#39;, reg_e=0.01)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Save the result with specific transport method</span>
<span class="sd">        &gt;&gt;&gt; adapted = image1.apply_adapt(</span>
<span class="sd">        &gt;&gt;&gt;      image2, mapping=&#39;sinkhorn&#39;, reg_e=0.01)</span>
<span class="sd">        &gt;&gt;&gt; adapted.save(&quot;adapted_image.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is useful for:</span>
<span class="sd">            - Harmonizing multi-sensor data while preserving originals</span>
<span class="sd">            - Testing different adaptation parameters</span>
<span class="sd">            - Creating multiple adaptations for comparison</span>
<span class="sd">        - For details on the different mapping methods, see the adapt() method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">InferenceTools</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imt</span><span class="p">,</span> <span class="n">tab_source</span> <span class="o">=</span> <span class="n">tab_source</span><span class="p">,</span> <span class="n">nb</span><span class="o">=</span><span class="n">nb</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="n">mapping</span><span class="p">,</span> <span class="n">reg_e</span><span class="o">=</span><span class="n">reg_e</span><span class="p">,</span>
                        <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by adapting spectral characteristics &#39;</span>
                                        <span class="sa">f</span><span class="s1">&#39;to match target image using </span><span class="si">{</span><span class="n">mapping</span><span class="si">}</span><span class="s1"> method&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>



    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image with standardized band values.</span>

<span class="sd">        This method performs statistical standardization of image bands, creating a new</span>
<span class="sd">        image where values have been transformed to have specific statistical properties,</span>
<span class="sd">        such as zero mean and unit variance (for &#39;standard&#39; type) or values in the 0-1</span>
<span class="sd">        range (for &#39;minmax&#39; type). This function can also apply a scaler (option `scaler`)</span>
<span class="sd">        to an image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaler : object or None, optional</span>
<span class="sd">            Scikit-learn scaler object to use. If None, a new scaler is created.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the standardized image. If None, image is not saved.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        type : {&#39;standard&#39;, &#39;minmax&#39;}, optional</span>
<span class="sd">            Type of standardization to apply:</span>
<span class="sd">            - &#39;standard&#39;: Standardize to zero mean and unit variance (z-scores)</span>
<span class="sd">            - &#39;minmax&#39;: Scale values to the range [0, 1]</span>
<span class="sd">            Default is &#39;standard&#39;.</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            Data type for the standardized image. Default is &#39;float64&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new image with standardized values</span>
<span class="sd">        object</span>
<span class="sd">            The scaler object used, which can be used for inverse transformation</span>
<span class="sd">            or for standardizing other images consistently</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Standard standardization (zero mean, unit variance)</span>
<span class="sd">        &gt;&gt;&gt; std_image, scaler = image.__apply_standardize()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Mean: {std_image.mean()}, Std: {std_image.std()}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Min-max scaling to [0, 1] range</span>
<span class="sd">        &gt;&gt;&gt; norm_image, scaler = image.__apply_standardize(type=&#39;minmax&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Min: {norm_image.min()}, Max: {norm_image.max()}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Standardize one image and apply same transformation to another</span>
<span class="sd">        &gt;&gt;&gt; _, scaler = reference.__apply_standardize()</span>
<span class="sd">        &gt;&gt;&gt; target_std = target.apply_standardize(scaler=scaler)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Standardization is essential for:</span>
<span class="sd">            - Machine learning algorithms that are sensitive to input scales</span>
<span class="sd">            - Comparing bands with different value ranges</span>
<span class="sd">            - Visualizing multiple bands with consistent contrast</span>
<span class="sd">        - &#39;standard&#39; is better for statistical analyses and most ML algorithms</span>
<span class="sd">        - &#39;minmax&#39; is better for visualization and algorithms requiring specific input ranges (like neural networks with sigmoid activation)</span>
<span class="sd">        - The returned scaler can be used for inverse_standardize() to recover original values or to ensure consistent transformation across images</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a new scaler if none is provided</span>
        <span class="k">if</span> <span class="n">scaler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Convert image to table for standardization</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">()</span>

            <span class="c1"># Create a copy and remove nodata values for scaler fitting</span>
            <span class="n">tab_std</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tab_std</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">tab_std</span> <span class="o">=</span> <span class="n">tab_std</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="c1"># Create and fit the appropriate scaler</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
                <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tab_std</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
                <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tab_std</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported standardization type: </span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Use &#39;standard&#39; or &#39;minmax&#39;.&quot;</span><span class="p">)</span>

            <span class="c1"># Apply the scaler to all data (including nodata)</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># Create metadata for the new image</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>

            <span class="c1"># Set band names</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Create new Geoimage from standardized data</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">table2image</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">standardized</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="n">standardized</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created using </span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s1"> standardization&#39;</span><span class="p">)</span>

            <span class="c1"># Save if requested</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">standardized</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">standardized</span><span class="p">,</span> <span class="n">scaler</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use the provided scaler</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">()</span>

            <span class="c1"># Apply the scaler</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># Create metadata for the new image</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>

            <span class="c1"># Set band names</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Create new Geoimage from standardized data</span>
            <span class="n">standardized</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">table2image</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">standardized</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="n">standardized</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created using provided scaler&#39;</span><span class="p">)</span>

            <span class="c1"># Save if requested</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">standardized</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">standardized</span>

<div class="viewcode-block" id="Geoimage.standardize">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.standardize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardize band values.</span>

<span class="sd">        This method performs statistical standardization of image bands, modifying</span>
<span class="sd">        the current image so values have specific statistical properties, such as</span>
<span class="sd">        zero mean and unit variance (for &#39;standard&#39; type) or values in the 0-1 range</span>
<span class="sd">        (for &#39;minmax&#39; type).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaler : object or None, optional</span>
<span class="sd">            Scikit-learn scaler object to use. If None, a new scaler is created.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the standardized image. If None, image is not saved.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        type : {&#39;standard&#39;, &#39;minmax&#39;}, optional</span>
<span class="sd">            Type of standardization to apply:</span>
<span class="sd">            - &#39;standard&#39;: Standardize to zero mean and unit variance (z-scores)</span>
<span class="sd">            - &#39;minmax&#39;: Scale values to the range [0, 1]</span>
<span class="sd">            Default is &#39;standard&#39;.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return the standardization in a new image. Otherwise, do standardization</span>
<span class="sd">            in place and return None.</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            Data type for the standardized image. Default is &#39;float64&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The image with standardized values or None if `inplace=True`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Standard standardization (zero mean, unit variance)</span>
<span class="sd">        &gt;&gt;&gt; im_standardized  = image.standardize()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Mean: {im_standardized.mean()}, Std: {im_standardized.std()}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Min-max scaling to [0, 1] range</span>
<span class="sd">        &gt;&gt;&gt; im_standardized  = iimage.standardize(type=&#39;minmax&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Min: {im_standardized.min()}, Max: {im_standardized.max()}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Standardize one image and apply same transformation to another (target)</span>
<span class="sd">        &gt;&gt;&gt; _, scaler = image.standardize()</span>
<span class="sd">        &gt;&gt;&gt; target_std = target.standardize(scaler=scaler)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Standard standardization of the image directly</span>
<span class="sd">        &gt;&gt;&gt; # With zero mean, unit variance</span>
<span class="sd">        &gt;&gt;&gt; image.standardize(inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Mean: {image.mean()}, Std: {image.std()}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # With min-max scaling to [0, 1] range</span>
<span class="sd">        &gt;&gt;&gt; image.standardize(type=&#39;minmax&#39;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Min: {image.min()}, Max: {image.max()}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Standardize one image and apply same transformation to another (target)</span>
<span class="sd">        &gt;&gt;&gt; _, scaler = image.standardize()</span>
<span class="sd">        &gt;&gt;&gt; target.standardize(scaler=scaler, inplace=True)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - When using a pre-fit scaler, make sure it was created with data having similar statistical properties.</span>
<span class="sd">        - Standardization is often a prerequisite for machine learning algorithms that are sensitive to data scales.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Create a new scaler if none is provided</span>
            <span class="k">if</span> <span class="n">scaler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Convert image to table for standardization</span>
                <span class="n">tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">()</span>

                <span class="c1"># Create a copy and remove nodata values for scaler fitting</span>
                <span class="n">tab_std</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tab_std</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">tab_std</span> <span class="o">=</span> <span class="n">tab_std</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

                <span class="c1"># Create and fit the appropriate scaler</span>
                <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
                    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tab_std</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
                    <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tab_std</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported standardization type: </span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">. &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Use &#39;standard&#39; or &#39;minmax&#39;.&quot;</span><span class="p">)</span>

                <span class="c1"># Apply the scaler to all data (including nodata)</span>
                <span class="n">tab</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

                <span class="c1"># Update metadata and image data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">table2image</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                <span class="c1"># Save if requested</span>
                <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Applied </span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s1"> standardization&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use the provided scaler</span>
                <span class="n">tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">()</span>

                <span class="c1"># Apply the scaler</span>
                <span class="n">tab</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

                <span class="c1"># Update metadata and image data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">table2image</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                <span class="c1"># Save if requested</span>
                <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Applied standardization using provided scaler&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_standardize</span><span class="p">(</span><span class="n">scaler</span><span class="o">=</span><span class="n">scaler</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_inverse_standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image by reverting standardization.</span>

<span class="sd">        This method creates a new image by applying the inverse of a standardization</span>
<span class="sd">        transformation, converting standardized values back to their original scale.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaler : object</span>
<span class="sd">            Scikit-learn scaler object that was used for the original standardization.</span>
<span class="sd">            This must have an inverse_transform() method (like StandardScaler or MinMaxScaler).</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the restored image. If None, image is not saved.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            Data type for the output image. Default is &#39;float64&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new image with values transformed back to the original scale</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create standardized version, then restore</span>
<span class="sd">        &gt;&gt;&gt; std_image, scaler = image.standardize()</span>
<span class="sd">        &gt;&gt;&gt; restored = std_image.__apply_inverse_standardize(scaler)</span>
<span class="sd">        &gt;&gt;&gt; diff = np.abs(restored.image - image.image).mean()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Mean absolute difference: {diff}&quot;)  # Should be very small</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Apply custom processing on standardized data, then restore scale</span>
<span class="sd">        &gt;&gt;&gt; std_img, scaler = image.standardize(type=&#39;minmax&#39;)</span>
<span class="sd">        &gt;&gt;&gt; processed = std_img * 0.8  # Apply some processing</span>
<span class="sd">        &gt;&gt;&gt; restored = processed.__apply_inverse_standardize(scaler)</span>
<span class="sd">        &gt;&gt;&gt; restored.save(&quot;processed_original_scale.tif&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is useful for:</span>
<span class="sd">            - Recovering original data values after analysis on standardized data</span>
<span class="sd">            - Applying processing in standardized space, then converting back</span>
<span class="sd">            - Ensuring output values are in a meaningful physical scale</span>
<span class="sd">        - The scaler must be the exact one used for the original standardization to ensure accurate inverse transformation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert image to table for inverse standardization</span>
        <span class="n">tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">()</span>

        <span class="c1"># Apply inverse transformation</span>
        <span class="n">tab</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Create metadata for the new image</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>

        <span class="c1"># Set band names</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Create new Geoimage from inverse-standardized data</span>
        <span class="n">inverted</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">table2image</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
            <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span>
            <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
            <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">inverted</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">inverted</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by applying inverse standardization&#39;</span><span class="p">)</span>

        <span class="c1"># Save if requested</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inverted</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inverted</span>

<div class="viewcode-block" id="Geoimage.inverse_standardize">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.inverse_standardize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">inverse_standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Revert standardization.</span>

<span class="sd">        This method creates an image by applying the inverse of a standardization</span>
<span class="sd">        transformation, converting standardized values back to their original scale.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaler : object</span>
<span class="sd">            Scikit-learn scaler object that was used for the original standardization.</span>
<span class="sd">            This must have an inverse_transform() method (like StandardScaler or MinMaxScaler).</span>
<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the restored image. If None, image is not saved.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy of the inverse standardization.</span>
<span class="sd">            Otherwise, do operation in place and return None.</span>
<span class="sd">        dtype : str, optional</span>
<span class="sd">            Data type for the output image. Default is &#39;float64&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The image with values transformed back to the original scale or None if `inplace=True`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Standardize and then restore original values</span>
<span class="sd">        &gt;&gt;&gt; image_copy = image.copy()</span>
<span class="sd">        &gt;&gt;&gt; image_copy_std, scaler = image_copy.standardize()</span>
<span class="sd">        &gt;&gt;&gt; image_copy_back = image_copy_std.inverse_standardize(scaler)</span>
<span class="sd">        &gt;&gt;&gt; image_copy_back.visu()  # Should look like the original</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # With inplace = True</span>
<span class="sd">        &gt;&gt;&gt; image_copy_std, scaler = image_copy.standardize()</span>
<span class="sd">        &gt;&gt;&gt; image_copy_std.inverse_standardize(scaler, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; image_copy_std.visu()  # Should look like the original</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The scaler must be the exact one used for the original standardization</span>
<span class="sd">          to ensure accurate inverse transformation</span>
<span class="sd">        - This is often used as the final step in a processing pipeline to convert</span>
<span class="sd">          results back to physically meaningful units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Convert image to table for inverse standardization</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_table</span><span class="p">()</span>

            <span class="c1"># Apply inverse transformation</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># Update metadata and image data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">table2image</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># Save if requested</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Applied inverse standardization&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_inverse_standardize</span><span class="p">(</span><span class="n">scaler</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.resampling">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.resampling">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">final_resolution</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cubic_spline&#39;</span><span class="p">,</span> <span class="n">update_history</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample the image to a different resolution.</span>

<span class="sd">        This method changes the spatial resolution of the image by resampling the pixel values.</span>
<span class="sd">        The resampling process creates a new grid of pixels at the target resolution and</span>
<span class="sd">        interpolates values from the original grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        final_resolution : float</span>
<span class="sd">            The target resolution in the image&#39;s coordinate system units (typically meters or degrees).</span>
<span class="sd">            A smaller value results in a higher-resolution (larger) image.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the resampled image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do the resampling in place and return None.</span>


<span class="sd">        method : str, optional</span>
<span class="sd">            Resampling algorithm to use. Options include:</span>

<span class="sd">            - &#39;cubic_spline&#39; (default): High-quality interpolation, good for continuous data</span>

<span class="sd">            - &#39;nearest&#39;: Nearest neighbor interpolation, preserves original values, best for categorical data</span>

<span class="sd">            - &#39;bilinear&#39;: Linear interpolation between points, faster than cubic</span>

<span class="sd">            - &#39;cubic&#39;: Standard cubic interpolation</span>

<span class="sd">            - &#39;lanczos&#39;: High-quality downsampling</span>

<span class="sd">            - &#39;average&#39;: Takes the average of all contributing pixels, useful for downsampling</span>

<span class="sd">        update_history : bool, optional</span>
<span class="sd">            Whether to update the image processing history. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A copy of the resampled image or None if `inplace=True`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Resample to 30 meter resolution</span>
<span class="sd">        &gt;&gt;&gt; image_resampled = image.resampling(30)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;New resolution: {image.resolution}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Resample using nearest neighbor (best for categorical data)</span>
<span class="sd">        &gt;&gt;&gt; classified_image_resampled = classified_image.resampling(10, method=&#39;nearest&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Resample and save the result</span>
<span class="sd">        &gt;&gt;&gt; image_resampled = image.resampling(20, dest_name=&#39;resampled_20m.tif&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Resample directly the image to 30 meter resolution</span>
<span class="sd">        &gt;&gt;&gt; image.resampling(30, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;New resolution: {image.resolution}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Resample directly the image using nearest neighbor (best for categorical data)</span>
<span class="sd">        &gt;&gt;&gt; classified_image.resampling(10, method=&#39;nearest&#39;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Resample and save the result</span>
<span class="sd">        &gt;&gt;&gt; image.resampling(20, dest_name=&#39;resampled_20m.tif&#39;, inplace=True)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - When upsampling (to higher resolution), no new information is created;</span>
<span class="sd">        the function only interpolates between existing pixels</span>
<span class="sd">        - When downsampling (to lower resolution), information is lost</span>
<span class="sd">        - The choice of resampling method is important:</span>
<span class="sd">        - For continuous data (e.g., elevation, reflectance): &#39;cubic_spline&#39;, &#39;bilinear&#39;, or &#39;cubic&#39;</span>
<span class="sd">        - For categorical data (e.g., land classifications): &#39;nearest&#39; or &#39;mode&#39;</span>
<span class="sd">        - This method changes the dimensions (shape) of the image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">original_resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span> <span class="o">=</span> <span class="n">resampling</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">final_resolution</span><span class="p">,</span>
                                                    <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span>
                                                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">update_history</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Resampled from </span><span class="si">{</span><span class="n">original_resolution</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">final_resolution</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> using </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1"> method&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Resampled image saved in: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resampling failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__apply_resampling</span><span class="p">(</span><span class="n">final_resolution</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">))</span></div>


<div class="viewcode-block" id="Geoimage.crop">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.crop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deb_row_lon</span><span class="p">,</span> <span class="n">end_row_lon</span><span class="p">,</span> <span class="n">deb_col_lat</span><span class="p">,</span> <span class="n">end_col_lat</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Crop the image to a specified extent.</span>

<span class="sd">        This method extracts a rectangular subset of the image, defined either by pixel</span>
<span class="sd">        coordinates or by geographic coordinates, and updates the current image to contain</span>
<span class="sd">        only the cropped region.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deb_row_lon : int or float</span>
<span class="sd">            Starting position:</span>
<span class="sd">            - If pixel=True: Starting row (y) coordinate</span>
<span class="sd">            - If pixel=False: Starting longitude coordinate</span>

<span class="sd">        end_row_lon : int or float</span>
<span class="sd">            Ending position:</span>
<span class="sd">            - If pixel=True: Ending row (y) coordinate</span>
<span class="sd">            - If pixel=False: Ending longitude coordinate</span>

<span class="sd">        deb_col_lat : int or float</span>
<span class="sd">            Starting position:</span>
<span class="sd">            - If pixel=True: Starting column (x) coordinate</span>
<span class="sd">            - If pixel=False: Starting latitude coordinate</span>

<span class="sd">        end_col_lat : int or float</span>
<span class="sd">            Ending position:</span>
<span class="sd">            - If pixel=True: Ending column (x) coordinate</span>
<span class="sd">            - If pixel=False: Ending latitude coordinate</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the cropped image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do cropping in place and return None.</span>

<span class="sd">        pixel : bool, optional</span>
<span class="sd">            Coordinate system flag:</span>
<span class="sd">            - If True: Coordinates are interpreted as pixel indices (row, col)</span>
<span class="sd">            - If False: Coordinates are interpreted as geographic coordinates (lon, lat)</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A copy of the cropped image or None if `inplace=True`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Crop using pixel coordinates</span>
<span class="sd">        &gt;&gt;&gt; original_shape = image.shape</span>
<span class="sd">        &gt;&gt;&gt; image_crop = image.crop(100, 500, 200, 600)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original shape: {original_shape}, New shape: {image_crop.shape}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Crop using geographic coordinates</span>
<span class="sd">        &gt;&gt;&gt; image_crop = image.crop(-122.5, -122.3, 37.8, 37.7, pixel=False)</span>
<span class="sd">        &gt;&gt;&gt; image.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Crop and save the result</span>
<span class="sd">        &gt;&gt;&gt; image_crop = image.crop(100, 500, 200, 600, dest_name=&#39;cropped_area.tif&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Crop using pixel coordinates</span>
<span class="sd">        &gt;&gt;&gt; original_shape = image.shape</span>
<span class="sd">        &gt;&gt;&gt; image.crop(100, 500, 200, 600, inplace=True) # inplace = True : modify directly the image</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original shape: {original_shape}, New shape: {image.shape}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Crop using geographic coordinates</span>
<span class="sd">        &gt;&gt;&gt; image.crop(-122.5, -122.3, 37.8, 37.7, pixel=False, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; image.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Crop and save the result</span>
<span class="sd">        &gt;&gt;&gt; image.crop(100, 500, 200, 600, dest_name=&#39;cropped_area.tif&#39;, inplace=True)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The cropping operation changes the spatial extent of the image but preserves</span>
<span class="sd">        the resolution and projection.</span>
<span class="sd">        - When using pixel coordinates, the format is (row_start, row_end, col_start, col_end).</span>
<span class="sd">        - When using geographic coordinates, the format is (lon_start, lon_end, lat_start, lat_end).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">original_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># Store original coordinates for history</span>
            <span class="n">orig_deb_row_lon</span> <span class="o">=</span> <span class="n">deb_row_lon</span>
            <span class="n">orig_end_row_lon</span> <span class="o">=</span> <span class="n">end_row_lon</span>
            <span class="n">orig_deb_col_lat</span> <span class="o">=</span> <span class="n">deb_col_lat</span>
            <span class="n">orig_end_col_lat</span> <span class="o">=</span> <span class="n">end_col_lat</span>

            <span class="c1"># Convert geographic coordinates to pixel coordinates if needed</span>
            <span class="k">if</span> <span class="n">pixel</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">row_deb</span><span class="p">,</span> <span class="n">col_deb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latlon2pixel</span><span class="p">(</span><span class="n">deb_col_lat</span><span class="p">,</span> <span class="n">deb_row_lon</span><span class="p">)</span>
                    <span class="n">row_end</span><span class="p">,</span> <span class="n">col_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latlon2pixel</span><span class="p">(</span><span class="n">end_col_lat</span><span class="p">,</span> <span class="n">end_row_lon</span><span class="p">)</span>
                    <span class="n">deb_row_lon_crop</span> <span class="o">=</span> <span class="n">row_deb</span>
                    <span class="n">end_row_lon_crop</span> <span class="o">=</span> <span class="n">row_end</span>
                    <span class="n">deb_col_lat_crop</span> <span class="o">=</span> <span class="n">col_deb</span>
                    <span class="n">end_col_lat_crop</span> <span class="o">=</span> <span class="n">col_end</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to convert geographic coordinates to pixel coordinates: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">deb_row_lon_crop</span> <span class="o">=</span> <span class="n">deb_row_lon</span>
                <span class="n">end_row_lon_crop</span> <span class="o">=</span> <span class="n">end_row_lon</span>
                <span class="n">deb_col_lat_crop</span> <span class="o">=</span> <span class="n">deb_col_lat</span>
                <span class="n">end_col_lat_crop</span> <span class="o">=</span> <span class="n">end_col_lat</span>

            <span class="c1"># Ensure coordinates are within image bounds</span>
            <span class="n">image_height</span><span class="p">,</span> <span class="n">image_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">pixel</span> <span class="ow">and</span> <span class="p">(</span><span class="n">deb_row_lon_crop</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">deb_col_lat_crop</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span>
                        <span class="n">end_row_lon_crop</span> <span class="o">&gt;</span> <span class="n">image_height</span> <span class="ow">or</span> <span class="n">end_col_lat_crop</span> <span class="o">&gt;</span> <span class="n">image_width</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Crop coordinates exceed image bounds (</span><span class="si">{</span><span class="n">image_height</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">image_width</span><span class="si">}</span><span class="s2">). &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Results will be clipped to image extent.&quot;</span><span class="p">)</span>

            <span class="c1"># Ensure end coordinates are greater than start coordinates</span>
            <span class="k">if</span> <span class="n">deb_row_lon_crop</span> <span class="o">&gt;</span> <span class="n">end_row_lon_crop</span><span class="p">:</span>
                <span class="n">deb_row_lon_crop</span><span class="p">,</span> <span class="n">end_row_lon_crop</span> <span class="o">=</span> <span class="n">end_row_lon_crop</span><span class="p">,</span> <span class="n">deb_row_lon_crop</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Start row/longitude greater than end row/longitude, swapping values.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">deb_col_lat_crop</span> <span class="o">&gt;</span> <span class="n">end_col_lat_crop</span><span class="p">:</span>
                <span class="n">deb_col_lat_crop</span><span class="p">,</span> <span class="n">end_col_lat_crop</span> <span class="o">=</span> <span class="n">end_col_lat_crop</span><span class="p">,</span> <span class="n">deb_col_lat_crop</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Start col/latitude greater than end col/latitude, swapping values.&quot;</span><span class="p">)</span>

            <span class="c1"># Perform the crop operation</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span> <span class="o">=</span> <span class="n">crop_rio</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                                                <span class="n">deb_row_lon_crop</span><span class="p">,</span> <span class="n">end_row_lon_crop</span><span class="p">,</span>
                                                <span class="n">deb_col_lat_crop</span><span class="p">,</span> <span class="n">end_col_lat_crop</span><span class="p">,</span>
                                                <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span>
                                                <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span>
                                                <span class="n">channel_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

                <span class="c1"># Add to history if enabled</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pixel</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Cropped from shape </span><span class="si">{</span><span class="n">original_shape</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;using pixel coordinates rows </span><span class="si">{</span><span class="n">orig_deb_row_lon</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">orig_end_row_lon</span><span class="si">}</span><span class="s1">, &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;cols </span><span class="si">{</span><span class="n">orig_deb_col_lat</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">orig_end_col_lat</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Cropped from shape </span><span class="si">{</span><span class="n">original_shape</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;using geographic coordinates lon </span><span class="si">{</span><span class="n">orig_deb_row_lon</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">orig_end_row_lon</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">, &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;lat </span><span class="si">{</span><span class="n">orig_deb_col_lat</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">orig_end_col_lat</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Cropped image saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cropping failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_crop</span><span class="p">(</span><span class="n">deb_row_lon</span><span class="p">,</span> <span class="n">end_row_lon</span><span class="p">,</span> <span class="n">deb_col_lat</span><span class="p">,</span> <span class="n">end_col_lat</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="n">pixel</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geoimage.select_bands">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.select_bands">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select only specified bands in the image</span>

<span class="sd">        This method modifies the image to contain only the specified bands, discarding</span>
<span class="sd">        all other bands. Band naming can be preserved or updated based on parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : str, list, int, or None, optional</span>
<span class="sd">            The bands to keep in the image. Format depends on band naming:</span>
<span class="sd">            - If using named bands: band name(s) as string(s) (e.g., &#39;NIR&#39;, [&#39;R&#39;, &#39;G&#39;, &#39;B&#39;])</span>
<span class="sd">            - If using indexed bands: band index/indices as int(s) or string(s) (e.g., 3, [&#39;1&#39;, &#39;4&#39;, &#39;7&#39;])</span>
<span class="sd">            If None, no bands are selected (invalid operation).</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the modified image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, modify the image by keeping only selected bands</span>

<span class="sd">        reformat_names : bool, optional</span>
<span class="sd">            Band naming behavior:</span>
<span class="sd">            - If True: Rename bands sequentially as &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, etc.</span>
<span class="sd">            - If False: Preserve original band names when possible</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The modified image with only selected bands or None if `inplace=True`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If no bands are specified, or if any specified band doesn&#39;t exist in the image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Extract only 3 specific bands</span>
<span class="sd">        &gt;&gt;&gt; original_bands = list(image.names.keys())</span>
<span class="sd">        &gt;&gt;&gt; image_selected = image.select_bands([&#39;NIR&#39;, &#39;Red&#39;, &#39;Green&#39;])</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original bands: {original_bands}, New bands: {list(image_selected.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Keep bands and renumber them sequentially</span>
<span class="sd">        &gt;&gt;&gt; image.select_bands([4, 3, 2], reformat_names=True, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Band names after reordering: {list(image.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Select a single band</span>
<span class="sd">        &gt;&gt;&gt; nir = image.select_bands(&#39;NIR&#39;, dest_name=&#39;nir_only.tif&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If band names contain duplicates, they will be automatically reformatted.</span>
<span class="sd">        - The band order in the result matches the order in the &#39;bands&#39; parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Check if bands parameter is provided</span>
            <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No bands specified for selection. Please provide at least one band name or index.&quot;</span><span class="p">)</span>

            <span class="c1"># Keep track of original bands for history</span>
            <span class="n">original_bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">original_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span>

            <span class="c1"># Convert bands to list of strings</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

            <span class="c1"># Validate band existence</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
            <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
                <span class="n">missing</span> <span class="o">=</span> <span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span>
                <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set2</span><span class="p">)))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following bands do not exist: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Get indices of selected bands</span>
                <span class="n">band_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">band</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>

                <span class="c1"># Keep only selected bands</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">band_indices</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

                <span class="c1"># Update metadata</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>

                <span class="c1"># Handle band naming</span>
                <span class="k">if</span> <span class="n">has_duplicates</span><span class="p">(</span><span class="n">bands</span><span class="p">):</span>
                    <span class="c1"># Force rename if duplicates are present</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__update_names</span><span class="p">()</span>
                    <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;renamed due to duplicates&quot;</span>
                <span class="k">elif</span> <span class="n">reformat_names</span><span class="p">:</span>
                    <span class="c1"># Rename if explicitly requested</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__update_names</span><span class="p">()</span>
                    <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;renamed sequentially&quot;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reformat_names</span><span class="p">:</span>
                    <span class="c1"># Preserve original names but update indices</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">reindex_dictionary_keep_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">bands</span><span class="p">)</span>
                    <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;preserved with updated indices&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Default fallback</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__update_names</span><span class="p">()</span>
                    <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;reset to defaults&quot;</span>

                <span class="c1"># Update derived properties</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

                <span class="c1"># Save if requested</span>
                <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">write_geoim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span>

                <span class="c1"># Update history if enabled</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Selected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">original_count</span><span class="si">}</span><span class="s1"> bands: </span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s1">. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Band names were </span><span class="si">{</span><span class="n">name_handling</span><span class="si">}</span><span class="s1">.&#39;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Image with selected bands saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band selection failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_bands</span><span class="p">(</span><span class="n">bands</span><span class="o">=</span><span class="n">bands</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="n">reformat_names</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">__get_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract specified bands into a new Geoimage without modifying the original.</span>

<span class="sd">        This method creates a new Geoimage containing only the specified bands,</span>
<span class="sd">        while preserving the original image. Unlike select_bands(), which modifies</span>
<span class="sd">        the original image, this method returns a new image with the selected bands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : str, list, int, or None, optional</span>
<span class="sd">            The bands to include in the new image. Format depends on band naming:</span>
<span class="sd">            - If using named bands: band name(s) as string(s) (e.g., &#39;NIR&#39;, [&#39;R&#39;, &#39;G&#39;, &#39;B&#39;])</span>
<span class="sd">            - If using indexed bands: band index/indices as int(s) or string(s) (e.g., 3, [&#39;1&#39;, &#39;4&#39;, &#39;7&#39;])</span>
<span class="sd">            If None, returns a copy of the entire image.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the new image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        reformat_names : bool, optional</span>
<span class="sd">            Band naming behavior:</span>
<span class="sd">            - If True: Rename bands sequentially as &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, etc.</span>
<span class="sd">            - If False: Preserve original band names when possible</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage containing only the specified bands.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any specified band doesn&#39;t exist in the image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Extract RGB bands</span>
<span class="sd">        &gt;&gt;&gt; rgb = image.__get_bands([&#39;R&#39;, &#39;G&#39;, &#39;B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; rgb.visu()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Extract a single band with its original name</span>
<span class="sd">        &gt;&gt;&gt; nir = image.__get_bands(&#39;NIR&#39;, dest_name=&#39;nir_band.tif&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;NIR band names: {nir.names}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Extract multiple bands and rename them sequentially</span>
<span class="sd">        &gt;&gt;&gt; subset = image.__get_bands([7, 4, 2], reformat_names=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Band names after extraction: {subset.names}&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If the original image has custom band names, they can be preserved in the new image.</span>
<span class="sd">        - This is useful for creating band subsets without modifying the original data.</span>
<span class="sd">        - For permanent modifications to the original image, use select_bands() instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no bands are specified, return a copy of the entire image</span>
        <span class="k">if</span> <span class="n">bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Convert bands to list of strings</span>
        <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

        <span class="c1"># Validate band existence</span>
        <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
        <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span>
            <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set2</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following bands do not exist: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get indices of selected bands</span>
            <span class="n">band_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">band</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>

            <span class="c1"># Extract selected bands</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">band_indices</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Explicit copy to avoid reference issues</span>

            <span class="c1"># Copy and update metadata</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

            <span class="c1"># Handle band naming based on parameters and conditions</span>
            <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">has_duplicates</span><span class="p">(</span><span class="n">bands</span><span class="p">):</span>
                <span class="c1"># Initialize new names if duplicates are present</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">initialize_dict</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;renamed sequentially due to duplicates&quot;</span>
            <span class="k">elif</span> <span class="n">reformat_names</span><span class="p">:</span>
                <span class="c1"># Initialize new names if reformatting is requested</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">initialize_dict</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;renamed sequentially as requested&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reformat_names</span><span class="p">:</span>
                <span class="c1"># Preserve original names but update indices</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">reindex_dictionary_keep_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">bands</span><span class="p">)</span>
                <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;preserved with updated indices&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default fallback</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">initialize_dict</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;set to default sequential names&quot;</span>

            <span class="c1"># Create new Geoimage with selected bands</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

            <span class="c1"># Copy history if present in original</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__history&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">activate_history</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__listhistory&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># Add extraction entry to history</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by extracting </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="si">}</span><span class="s1"> bands: </span><span class="si">{</span><span class="n">bands</span><span class="si">}</span><span class="s1">. &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;Band names were </span><span class="si">{</span><span class="n">name_handling</span><span class="si">}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>

            <span class="c1"># Save if requested</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band extraction failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

<div class="viewcode-block" id="Geoimage.stack">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.stack">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im_to_stack</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stack bands from another image onto this image.</span>

<span class="sd">        This method combines the bands from another image with the current image,</span>
<span class="sd">        modifying the current image to include all bands from both sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        im_to_stack : Geoimage</span>
<span class="sd">            The image whose bands will be stacked onto this image.</span>
<span class="sd">            Should have the same spatial dimensions (rows, cols).</span>

<span class="sd">        dtype : str or None, optional</span>
<span class="sd">            The data type for the stacked image. If None, an appropriate type is</span>
<span class="sd">            determined based on the types of both input images.</span>
<span class="sd">            Common values: &#39;float64&#39;, &#39;float32&#39;, &#39;int32&#39;, &#39;uint16&#39;, &#39;uint8&#39;.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the stacked image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy of the stacked image. Otherwise, do stacking in place and return None.</span>

<span class="sd">        reformat_names : bool, optional</span>
<span class="sd">            If True, band names will be reset to a simple numeric format (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, ...).</span>
<span class="sd">            If False, the function will preserve original band names where possible,</span>
<span class="sd">            adding suffixes if needed to resolve conflicts.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The image with additional bands or None if `inplace=True`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the spatial dimensions of the images don&#39;t match or an unknown dtype is specified.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Stack two images with different spectral bands</span>
<span class="sd">        &gt;&gt;&gt; optical = Geoimage(&quot;optical.tif&quot;, names={&#39;R&#39;: 1, &#39;G&#39;: 2, &#39;B&#39;: 3})</span>
<span class="sd">        &gt;&gt;&gt; thermal = Geoimage(&quot;thermal.tif&quot;, names={&#39;T&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; combined = optical.stack(thermal)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Combined bands: {list(combined.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Stack and rename bands sequentially</span>
<span class="sd">        &gt;&gt;&gt; combined = optical.stack(thermal, reformat_names=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;After renaming: {list(combined.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Stack with explicit data type</span>
<span class="sd">        &gt;&gt;&gt; combined = optical.stack(thermal, dtype=&#39;float32&#39;, dest_name=&#39;combined.tif&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Stack in the image directly</span>
<span class="sd">        &gt;&gt;&gt; optical.stack(thermal, reformat_names=True, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;After renaming: {list(combined.names.keys())}&quot;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The bands from both images are combined along the band dimension (axis 0).</span>
<span class="sd">        - Band naming conflicts are resolved automatically, adding suffixes if needed.</span>
<span class="sd">        - The spatial dimensions (rows, cols) of both images must match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Validate spatial dimensions match</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Images have different spatial dimensions: &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">im_to_stack</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Images must have the same dimensions to stack.&quot;</span><span class="p">)</span>

            <span class="c1"># Track original band count</span>
            <span class="n">original_band_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span>
            <span class="n">stacked_band_count</span> <span class="o">=</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">nb_bands</span>

            <span class="c1"># Determine the output data type</span>
            <span class="n">original_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>
            <span class="n">stacked_dtype</span> <span class="o">=</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Use the explicitly specified dtype</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Auto-determine best dtype based on input dtypes</span>
                <span class="n">dtype_priority</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;float64&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                    <span class="s1">&#39;uint16&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;uint8&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;int8&#39;</span><span class="p">:</span> <span class="mi">7</span>
                <span class="p">}</span>

                <span class="c1"># Define dtype promotion rules for pairs of dtypes</span>
                <span class="n">dtype_promotion</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">):</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">):</span> <span class="s1">&#39;uint16&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;uint16&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">):</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">):</span> <span class="s1">&#39;int16&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;int16&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">):</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">):</span> <span class="s1">&#39;uint16&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">):</span> <span class="s1">&#39;int16&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;uint8&#39;</span><span class="p">):</span> <span class="s1">&#39;uint8&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;int8&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;int8&#39;</span>
                <span class="p">}</span>

                <span class="c1"># Sort dtypes by priority (higher priority first)</span>
                <span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">original_dtype</span><span class="p">,</span> <span class="n">stacked_dtype</span><span class="p">],</span>
                                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dtype_priority</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">999</span><span class="p">))</span>

                <span class="c1"># Look up the promotion rule</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dtype_promotion</span> <span class="k">else</span> <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype_promotion</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>

            <span class="c1"># Handle band naming</span>
            <span class="k">if</span> <span class="n">has_common_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
                <span class="c1"># If there are common band names, add suffixes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">concat_dicts_with_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;disambiguated with suffixes due to name conflicts&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If no conflicts, combine directly</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">concat_dicts_with_keys_unmodified</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;combined without modification (no conflicts)&quot;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Convert and concatenate bands</span>
                <span class="n">target_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">),</span>
                    <span class="n">im_to_stack</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">)),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>

                <span class="c1"># Update metadata</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

                <span class="c1"># Reset names if requested</span>
                <span class="k">if</span> <span class="n">reformat_names</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reset_names</span><span class="p">()</span>
                    <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;reset to sequential numbering&quot;</span>

                <span class="c1"># Update other metadata and derived properties</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

                <span class="c1"># Save if requested</span>
                <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">write_geoim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span>

                <span class="c1"># Update history if enabled</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                    <span class="n">band_list</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">im_to_stack</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Stacked </span><span class="si">{</span><span class="n">stacked_band_count</span><span class="si">}</span><span class="s1"> bands (</span><span class="si">{</span><span class="n">band_list</span><span class="si">}</span><span class="s1">) onto existing </span><span class="si">{</span><span class="n">original_band_count</span><span class="si">}</span><span class="s1"> bands. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Output type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">. Band names were </span><span class="si">{</span><span class="n">name_handling</span><span class="si">}</span><span class="s1">.&#39;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Stacked image saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stacking failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_stack</span><span class="p">(</span><span class="n">im_to_stack</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="n">reformat_names</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im_to_stack</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image by stacking bands from another image.</span>

<span class="sd">        This method creates a new Geoimage by combining the bands from the current image</span>
<span class="sd">        with those from another image. Unlike stack(), this method doesn&#39;t modify</span>
<span class="sd">        the original images but returns a new one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        im_to_stack : Geoimage</span>
<span class="sd">            The image whose bands will be stacked onto this image.</span>
<span class="sd">            Should have the same spatial dimensions (rows, cols).</span>

<span class="sd">        dtype : str or None, optional</span>
<span class="sd">            The data type for the stacked image. If None, an appropriate type is</span>
<span class="sd">            determined based on the types of both input images.</span>
<span class="sd">            Common values: &#39;float64&#39;, &#39;float32&#39;, &#39;int32&#39;, &#39;uint16&#39;, &#39;uint8&#39;.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the stacked image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        reformat_names : bool, optional</span>
<span class="sd">            If True, band names will be reset to a simple numeric format (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, ...).</span>
<span class="sd">            If False, the function will preserve original band names where possible,</span>
<span class="sd">            adding suffixes if needed to resolve conflicts.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage containing all bands from both input images.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the spatial dimensions of the images don&#39;t match or an unknown dtype is specified.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Stack two images while preserving the originals</span>
<span class="sd">        &gt;&gt;&gt; optical = Geoimage(&quot;optical.tif&quot;, names={&#39;R&#39;: 1, &#39;G&#39;: 2, &#39;B&#39;: 3})</span>
<span class="sd">        &gt;&gt;&gt; thermal = Geoimage(&quot;thermal.tif&quot;, names={&#39;T&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; combined = optical.apply_stack(thermal)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Combined bands: {list(combined.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original optical bands: {list(optical.names.keys())}&quot;)  # Unchanged</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Stack with simplified band naming</span>
<span class="sd">        &gt;&gt;&gt; combined = optical.apply_stack(thermal, reformat_names=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Sequential band names: {list(combined.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Stack with explicit data type and save</span>
<span class="sd">        &gt;&gt;&gt; combined = optical.apply_stack(thermal, dtype=&#39;float32&#39;, dest_name=&#39;combined.tif&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method creates a new image without modifying the inputs.</span>
<span class="sd">        - The bands from both images are combined along the band dimension (axis 0).</span>
<span class="sd">        - Band naming conflicts are resolved automatically, adding suffixes if needed.</span>
<span class="sd">        - The spatial dimensions (rows, cols) of both images must match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate spatial dimensions match</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Images have different spatial dimensions: &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">im_to_stack</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Images must have the same dimensions to stack.&quot;</span><span class="p">)</span>

        <span class="c1"># Track band counts for documentation</span>
        <span class="n">orig_band_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span>
        <span class="n">stack_band_count</span> <span class="o">=</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">nb_bands</span>

        <span class="c1"># Make a copy of metadata</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Determine the output data type</span>
        <span class="n">orig_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>
        <span class="n">stack_dtype</span> <span class="o">=</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use the explicitly specified dtype</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Auto-determine best dtype based on input dtypes</span>
            <span class="n">dtype_priority</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;float64&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                <span class="s1">&#39;uint16&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;uint8&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;int8&#39;</span><span class="p">:</span> <span class="mi">7</span>
            <span class="p">}</span>

            <span class="c1"># Define dtype promotion rules for pairs of dtypes</span>
            <span class="n">dtype_promotion</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">):</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">):</span> <span class="s1">&#39;uint16&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;uint16&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">):</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">):</span> <span class="s1">&#39;int16&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;int16&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">):</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">):</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">):</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">):</span> <span class="s1">&#39;uint16&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">):</span> <span class="s1">&#39;int16&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="s1">&#39;uint8&#39;</span><span class="p">):</span> <span class="s1">&#39;uint8&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="s1">&#39;int8&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">):</span> <span class="s1">&#39;int8&#39;</span>
            <span class="p">}</span>

            <span class="c1"># Sort dtypes by priority (higher priority first)</span>
            <span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">orig_dtype</span><span class="p">,</span> <span class="n">stack_dtype</span><span class="p">],</span>
                                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dtype_priority</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">999</span><span class="p">))</span>

            <span class="c1"># Look up the promotion rule</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dtype_promotion</span> <span class="k">else</span> <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">)</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtype_promotion</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>

        <span class="c1"># Handle band naming</span>
        <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">has_common_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="c1"># If there are common band names, add suffixes</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">concat_dicts_with_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;disambiguated with suffixes due to name conflicts&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If no conflicts, combine directly</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">concat_dicts_with_keys_unmodified</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">im_to_stack</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;combined without modification (no conflicts)&quot;</span>

        <span class="c1"># Apply band renaming if requested</span>
        <span class="k">if</span> <span class="n">reformat_names</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">initialize_dict</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
            <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;reset to sequential numbering&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Convert and concatenate bands</span>
            <span class="n">target_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">])</span>
            <span class="n">stacked_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">),</span>
                <span class="n">im_to_stack</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">)),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

            <span class="c1"># Update metadata count</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

            <span class="c1"># Create new Geoimage with stacked data</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">stacked_image</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

            <span class="c1"># Initialize history if needed</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__history&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">activate_history</span><span class="p">()</span>

                <span class="c1"># Copy existing history if available</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__listhistory&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># Add stacking entry to history</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>

                <span class="n">stack_bands</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">im_to_stack</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by stacking </span><span class="si">{</span><span class="n">orig_band_count</span><span class="si">}</span><span class="s1"> bands from first image with &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stack_band_count</span><span class="si">}</span><span class="s1"> bands (</span><span class="si">{</span><span class="n">stack_bands</span><span class="si">}</span><span class="s1">) from second image. &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;Output type: </span><span class="si">{</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">. Band names were </span><span class="si">{</span><span class="n">name_handling</span><span class="si">}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>

            <span class="c1"># Save if requested</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Stacked image saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stacking failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

<div class="viewcode-block" id="Geoimage.remove_bands">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.remove_bands">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove specified bands from the image.</span>

<span class="sd">        This method modifies the current image by removing the specified bands.</span>
<span class="sd">        The remaining bands can be renamed sequentially or retain their original names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : str, list, int, or array-like</span>
<span class="sd">            The bands to remove from the image. Format depends on band naming:</span>
<span class="sd">            - If using named bands: band name(s) as string(s) (e.g., &#39;NIR&#39;, [&#39;R&#39;, &#39;G&#39;, &#39;B&#39;])</span>
<span class="sd">            - If using indexed bands: band index/indices as int(s) or string(s) (e.g., 3, [&#39;1&#39;, &#39;4&#39;, &#39;7&#39;])</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do removing in place and return None.</span>


<span class="sd">        reformat_names : bool, optional</span>
<span class="sd">            Band naming behavior after removal:</span>
<span class="sd">            - If True: Rename remaining bands sequentially as &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, etc.</span>
<span class="sd">            - If False: Preserve original band names with their indices updated</span>
<span class="sd">            Default is False.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the modified image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The image with specified bands removed or None if `inplace=True`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any specified band doesn&#39;t exist in the image, or if removing all bands.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Remove a single band</span>
<span class="sd">        &gt;&gt;&gt; original_bands = list(image.names.keys())</span>
<span class="sd">        &gt;&gt;&gt; image_removed = image.remove_bands(&#39;B4&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original: {original_bands}, After removal: {list(image_removed.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Remove multiple bands and rename sequentially</span>
<span class="sd">        &gt;&gt;&gt; image_removed = image.remove_bands([&#39;B1&#39;, &#39;B2&#39;], reformat_names=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;After renaming: {list(image_removed = .names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Remove bands and save the result</span>
<span class="sd">        &gt;&gt;&gt; image_removed = image.remove_bands([&#39;SWIR1&#39;, &#39;SWIR2&#39;], dest_name=&#39;visible_only.tif&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Remove a single band</span>
<span class="sd">        &gt;&gt;&gt; original_bands = list(image.names.keys())</span>
<span class="sd">        &gt;&gt;&gt; image.remove_bands(&#39;B4&#39;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original: {original_bands}, After removal: {list(image.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Remove multiple bands and rename sequentially</span>
<span class="sd">        &gt;&gt;&gt; image.remove_bands([&#39;B1&#39;, &#39;B2&#39;], reformat_names=True, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;After renaming: {list(image.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Remove bands and save the result</span>
<span class="sd">        &gt;&gt;&gt; image.remove_bands([&#39;SWIR1&#39;, &#39;SWIR2&#39;], dest_name=&#39;visible_only.tif&#39;, inplace=True)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If reformat_names=False (default), band names are preserved but indices are updated.</span>
<span class="sd">        - If reformat_names=True, bands are renamed sequentially (1, 2, 3, ...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Convert bands to list of strings</span>
            <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

            <span class="c1"># Track original state for history</span>
            <span class="n">original_band_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span>
            <span class="n">original_bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="c1"># Validate band existence</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
            <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
                <span class="n">missing</span> <span class="o">=</span> <span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span>
                <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set2</span><span class="p">)))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following bands do not exist: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Check if trying to remove all bands</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot remove all bands. You&#39;re trying to remove </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;bands from an image with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="si">}</span><span class="s2"> bands.&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Get indices of bands to remove</span>
                <span class="n">band_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">band</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>

                <span class="c1"># Create a mask for bands to keep</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_nb_bands</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">band_indices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># Keep only non-masked bands</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

                <span class="c1"># Update metadata count</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>

                <span class="c1"># Record naming approach for history</span>
                <span class="k">if</span> <span class="n">reformat_names</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__update_names</span><span class="p">()</span>
                    <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;reset to sequential numbering&quot;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reformat_names</span><span class="p">:</span>
                    <span class="c1"># Preserve original names but update indices</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">reindex_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">bands</span><span class="p">)</span>
                    <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;preserved with updated indices&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Default fallback</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__update_names</span><span class="p">()</span>
                    <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;reset to defaults&quot;</span>

                <span class="c1"># Update derived properties</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

                <span class="c1"># Save if requested</span>
                <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">write_geoim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span>

                <span class="c1"># Update history if enabled</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                    <span class="n">remaining</span> <span class="o">=</span> <span class="n">original_band_count</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
                    <span class="n">removed_bands</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Removed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">original_band_count</span><span class="si">}</span><span class="s1"> bands: </span><span class="si">{</span><span class="n">removed_bands</span><span class="si">}</span><span class="s1">. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">remaining</span><span class="si">}</span><span class="s1"> bands remain. Band names were </span><span class="si">{</span><span class="n">name_handling</span><span class="si">}</span><span class="s1">.&#39;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Image with removed bands saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band removal failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_remove_bands</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="n">reformat_names</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_remove_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">reformat_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image with specified bands removed.</span>

<span class="sd">        This method creates a new Geoimage without the specified bands, while preserving</span>
<span class="sd">        the original image. Unlike remove_bands() which modifies the original image,</span>
<span class="sd">        this method returns a new image with the specified bands removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bands : str, list, int, or array-like</span>
<span class="sd">            The bands to remove from the image. Format depends on band naming:</span>
<span class="sd">            - If using named bands: band name(s) as string(s) (e.g., &#39;NIR&#39;, [&#39;R&#39;, &#39;G&#39;, &#39;B&#39;])</span>
<span class="sd">            - If using indexed bands: band index/indices as int(s) or string(s) (e.g., 3, [&#39;1&#39;, &#39;4&#39;, &#39;7&#39;])</span>

<span class="sd">        reformat_names : bool, optional</span>
<span class="sd">            Band naming behavior in the new image:</span>
<span class="sd">            - If True: Rename remaining bands sequentially as &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, etc.</span>
<span class="sd">            - If False: Preserve original band names with their indices updated</span>
<span class="sd">            Default is False.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the new image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with the specified bands removed.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any specified band doesn&#39;t exist in the image, or if trying to remove all bands.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a new image without certain bands</span>
<span class="sd">        &gt;&gt;&gt; original = Geoimage(&quot;multispectral.tif&quot;, names={&#39;R&#39;: 1, &#39;G&#39;: 2, &#39;B&#39;: 3, &#39;NIR&#39;: 4})</span>
<span class="sd">        &gt;&gt;&gt; rgb_only = original.apply_remove_bands(&#39;NIR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original bands: {list(original.names.keys())}&quot;)  # Unchanged</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;New bands: {list(rgb_only.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Remove multiple bands and rename sequentially</span>
<span class="sd">        &gt;&gt;&gt; visible = original.apply_remove_bands([&#39;NIR&#39;, &#39;SWIR&#39;], reformat_names=True)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;New sequential names: {list(visible.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create a subset and save it</span>
<span class="sd">        &gt;&gt;&gt; subset = original.apply_remove_bands([&#39;B1&#39;, &#39;B7&#39;], dest_name=&#39;subset.tif&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method creates a new image without modifying the original.</span>
<span class="sd">        - For permanent modifications to the original image, use remove_bands() instead.</span>
<span class="sd">        - If trying to select specific bands to keep (rather than remove), __get_bands()</span>
<span class="sd">        might be more straightforward.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert bands to list of strings</span>
        <span class="n">bands</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>

        <span class="c1"># Validate band existence</span>
        <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
        <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span>
            <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set2</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following bands do not exist: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Check if trying to remove all bands</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot remove all bands. You&#39;re trying to remove </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;bands from an image with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="si">}</span><span class="s2"> bands.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get indices of bands to remove</span>
            <span class="n">band_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">band</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>

            <span class="c1"># Create a mask for bands to keep</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_nb_bands</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">band_indices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Extract only non-masked bands</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Explicit copy to avoid reference issues</span>

            <span class="c1"># Copy and update metadata</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Handle band naming based on parameters</span>
            <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">reformat_names</span><span class="p">:</span>
                <span class="c1"># Initialize new names if reformatting is requested</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">initialize_dict</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;reset to sequential numbering&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__namesgiven</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">reformat_names</span><span class="p">:</span>
                <span class="c1"># Preserve original names but update indices</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">reindex_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">bands</span><span class="p">)</span>
                <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;preserved with updated indices&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default fallback</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">initialize_dict</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">name_handling</span> <span class="o">=</span> <span class="s2">&quot;set to default sequential names&quot;</span>

            <span class="c1"># Create new Geoimage with remaining bands</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

            <span class="c1"># Copy history if present in original</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__history&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">activate_history</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__listhistory&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># Add removal entry to history</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="n">removed_bands</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
                <span class="n">remaining</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created by removing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="si">}</span><span class="s1"> bands: </span><span class="si">{</span><span class="n">removed_bands</span><span class="si">}</span><span class="s1">. &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">remaining</span><span class="si">}</span><span class="s1"> bands remain. Band names were </span><span class="si">{</span><span class="n">name_handling</span><span class="si">}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>

            <span class="c1"># Save if requested</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band removal failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

<div class="viewcode-block" id="Geoimage.reorder_bands">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.reorder_bands">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reorder_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_order</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder the image bands according to the specified order.</span>

<span class="sd">        This method changes the order of bands in the image based on the specified</span>
<span class="sd">        band_order parameter. The current image is modified in-place or in a new Geoimage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        band_order : list or dict</span>
<span class="sd">            The desired band order specification:</span>
<span class="sd">            - If list: A list of band names in the desired order</span>
<span class="sd">            Example: [&#39;NIR&#39;, &#39;Red&#39;, &#39;Green&#39;, &#39;Blue&#39;]</span>
<span class="sd">            - If dict: A dictionary mapping band names to their desired positions (1-based)</span>
<span class="sd">            Example: {&#39;NIR&#39;: 1, &#39;Red&#39;: 2, &#39;Green&#39;: 3, &#39;Blue&#39;: 4}</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do reorder bands in place and return None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A copy of the image with reordered bands or None if `inplace=True`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If band_order is not a list or dictionary, or if it contains bands</span>
<span class="sd">            that don&#39;t exist in the image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Reorder bands using a list (most common usage)</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # Shows original band order</span>
<span class="sd">        &gt;&gt;&gt; image_reorder = image.reorder_bands([&#39;B6&#39;, &#39;B5&#39;, &#39;B4&#39;])</span>
<span class="sd">        &gt;&gt;&gt; image_reorder.info()  # Shows new band order</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Directly reorder bands using a dictionary with explicit positions</span>
<span class="sd">        &gt;&gt;&gt; image.reorder_bands({&#39;NIR&#39;: 1, &#39;Red&#39;: 2, &#39;Green&#39;: 3}, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Reorder bands and save</span>
<span class="sd">        &gt;&gt;&gt; image.reorder_bands([&#39;R&#39;, &#39;G&#39;, &#39;B&#39;]).save(&#39;rgb_order.tif&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All bands in the image must be included in band_order if using a list.</span>
<span class="sd">        - If using a dictionary, bands not specified will be excluded.</span>
<span class="sd">        - The band indices in the result will be updated to match the new order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">original_bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Handle list-based ordering</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_order</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="c1"># Convert all elements to strings</span>
                    <span class="n">band_order</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span>

                    <span class="c1"># Validate that all specified bands exist</span>
                    <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span>
                    <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
                        <span class="n">missing</span> <span class="o">=</span> <span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span>
                        <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set2</span><span class="p">)))</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following bands do not exist: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># Validate that all bands are accounted for in list mode</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="p">:</span>
                            <span class="n">missing_bands</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span>
                            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not all bands specified in reordering list. &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Missing bands: </span><span class="si">{</span><span class="n">missing_bands</span><span class="si">}</span><span class="s2">. &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Use a dictionary if you want to exclude some bands.&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too many bands specified in reordering list. &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Image has </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="si">}</span><span class="s2"> bands, but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span><span class="si">}</span><span class="s2"> were provided.&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

                    <span class="c1"># Get the reordered bands</span>
                    <span class="n">im2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_bands</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span>

                <span class="c1"># Handle dictionary-based ordering</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_order</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="c1"># Validate dictionary values</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">band_order</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dictionary values must be numbers representing band positions.&quot;</span><span class="p">)</span>

                    <span class="c1"># Convert to string keys if needed</span>
                    <span class="n">band_order</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">band_order</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

                    <span class="c1"># Validate that all specified bands exist</span>
                    <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_order</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
                        <span class="n">missing</span> <span class="o">=</span> <span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span>
                        <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set2</span><span class="p">)))</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following bands do not exist: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># Reorder bands based on the dictionary</span>
                    <span class="n">names_to_keep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">reorder_dict_by_values</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="n">im2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_bands</span><span class="p">(</span><span class="n">names_to_keep</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;band_order must be a list or a dictionary.&quot;</span><span class="p">)</span>

                <span class="c1"># Update the current image with the reordered bands</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">im2</span><span class="p">)</span>

                <span class="c1"># Add to history if enabled</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__history&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_order</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">ordering_type</span> <span class="o">=</span> <span class="s2">&quot;list-based&quot;</span>
                        <span class="n">new_order</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ordering_type</span> <span class="o">=</span> <span class="s2">&quot;dictionary-based&quot;</span>
                        <span class="n">ordered_bands</span> <span class="o">=</span> <span class="n">reorder_dict_by_values</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span>
                        <span class="n">new_order</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ordered_bands</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Reordered bands using </span><span class="si">{</span><span class="n">ordering_type</span><span class="si">}</span><span class="s1"> ordering. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Original order: </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">original_bands</span><span class="p">)</span><span class="si">}</span><span class="s1">. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;New order: </span><span class="si">{</span><span class="n">new_order</span><span class="si">}</span><span class="s1">.&#39;</span>
                    <span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band reordering failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_reorder_bands</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_reorder_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image with bands reordered according to the specified order.</span>

<span class="sd">        This method creates a new Geoimage with bands rearranged according to the</span>
<span class="sd">        specified band_order parameter. Unlike reorder_bands(), this method doesn&#39;t</span>
<span class="sd">        modify the original image but returns a new one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        band_order : list or dict</span>
<span class="sd">            The desired band order specification:</span>
<span class="sd">            - If list: A list of band names in the desired order</span>
<span class="sd">            Example: [&#39;NIR&#39;, &#39;Red&#39;, &#39;Green&#39;, &#39;Blue&#39;]</span>
<span class="sd">            - If dict: A dictionary mapping band names to their desired positions (1-based)</span>
<span class="sd">            Example: {&#39;NIR&#39;: 1, &#39;Red&#39;: 2, &#39;Green&#39;: 3, &#39;Blue&#39;: 4}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with reordered bands.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If band_order is not a list or dictionary, or if it contains bands</span>
<span class="sd">            that don&#39;t exist in the image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a new image with reordered bands</span>
<span class="sd">        &gt;&gt;&gt; original = Geoimage(&quot;multispectral.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt; rgb_order = original.__apply_reorder_bands([&#39;R&#39;, &#39;G&#39;, &#39;B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original bands: {list(original.names.keys())}&quot;)  # Unchanged</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Reordered bands: {list(rgb_order.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Reorder using a dictionary with explicit positions</span>
<span class="sd">        &gt;&gt;&gt; nir_rgb = original.__apply_reorder_bands({&#39;NIR&#39;: 1, &#39;R&#39;: 2, &#39;G&#39;: 3, &#39;B&#39;: 4})</span>
<span class="sd">        &gt;&gt;&gt; nir_rgb.save(&#39;nir_rgb.tif&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - All bands in the image must be included in band_order if using a list.</span>
<span class="sd">        - If using a dictionary, bands not specified will be excluded from the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Create a copy of the original image</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Apply reordering to the copy</span>
            <span class="n">result</span><span class="o">.</span><span class="n">reorder_bands</span><span class="p">(</span><span class="n">band_order</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Update history if available</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;__history&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_order</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">ordering_type</span> <span class="o">=</span> <span class="s2">&quot;list-based&quot;</span>
                    <span class="n">new_order</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">band_order</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ordering_type</span> <span class="o">=</span> <span class="s2">&quot;dictionary-based&quot;</span>
                    <span class="n">ordered_bands</span> <span class="o">=</span> <span class="n">reorder_dict_by_values</span><span class="p">(</span><span class="n">band_order</span><span class="p">)</span>
                    <span class="n">new_order</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ordered_bands</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

                <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created as a copy with reordered bands using </span><span class="si">{</span><span class="n">ordering_type</span><span class="si">}</span><span class="s1"> ordering. &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;New order: </span><span class="si">{</span><span class="n">new_order</span><span class="si">}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating image with reordered bands failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

<div class="viewcode-block" id="Geoimage.switch_band">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.switch_band">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">switch_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_to_switch</span><span class="p">,</span> <span class="n">band_to_position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the position of a specified band in the image.</span>

<span class="sd">        This method modifies the current image by moving a specified band to a new</span>
<span class="sd">        position, either at the beginning of the band sequence or after a specific band.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        band_to_switch : str, int, or list</span>
<span class="sd">            The band(s) to move to a new position. Can be specified as a band name,</span>
<span class="sd">            band index, or a list containing a single band identifier.</span>

<span class="sd">        band_to_position : str, int, or None, optional</span>
<span class="sd">            The target position specification:</span>
<span class="sd">            - If None: Move the band to the first position (beginning of the sequence)</span>
<span class="sd">            - If specified: Move the band to the position immediately after this band</span>
<span class="sd">            Default is None.</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do switch in place and return None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The image with the reordered bands or None if `inplace=True`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If specified bands don&#39;t exist or if input parameters are invalid.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Move NIR band to the first position</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # Check original band order</span>
<span class="sd">        &gt;&gt;&gt; im_switch = image.switch_band(&#39;NIR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; im_switch.info()  # NIR is now the first band</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Move SWIR band to position after Red band</span>
<span class="sd">        &gt;&gt;&gt; im_switch = image.switch_band(&#39;SWIR&#39;, &#39;Red&#39;)</span>
<span class="sd">        &gt;&gt;&gt; im_switch.info()  # SWIR now follows Red</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Using band indices instead of names</span>
<span class="sd">        &gt;&gt;&gt; iim_switch = mage.switch_band(5, 2)  # Move band 5 to after band 2</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Move NIR band to the first position and change image directly</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # Check original band order</span>
<span class="sd">        &gt;&gt;&gt; image.switch_band(&#39;NIR&#39;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # NIR is now the first band</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Move SWIR band to position after Red band</span>
<span class="sd">        &gt;&gt;&gt; image.switch_band(&#39;SWIR&#39;, &#39;Red&#39;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; image.info()  # SWIR now follows Red</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Using band indices instead of names</span>
<span class="sd">        &gt;&gt;&gt; image.switch_band(5, 2, inplace=True)  # Move band 5 to after band 2</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - When multiple bands should be moved as a unit, provide them in a list</span>
<span class="sd">        as the band_to_switch parameter.</span>
<span class="sd">        - The band indices in the result will be updated to reflect the new order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">original_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Ensure band_to_switch is a list of strings</span>
                <span class="n">band_to_switch</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">band_to_switch</span><span class="p">)</span>

                <span class="c1"># Validate band_to_switch existence</span>
                <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_to_switch</span><span class="p">)</span>
                <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">set1</span> <span class="o">&lt;=</span> <span class="n">set2</span><span class="p">):</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span>
                    <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set2</span><span class="p">)))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following bands to switch do not exist: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Case 1: Move to the beginning (no target position)</span>
                <span class="k">if</span> <span class="n">band_to_position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Extract the band(s) to move</span>
                    <span class="n">ima</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_bands</span><span class="p">(</span><span class="n">band_to_switch</span><span class="p">)</span>

                    <span class="c1"># Remove those band(s) from the original</span>
                    <span class="n">imb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_remove_bands</span><span class="p">(</span><span class="n">band_to_switch</span><span class="p">)</span>

                    <span class="c1"># Place the extracted band(s) at the beginning</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">ima</span><span class="o">.</span><span class="n">__apply_stack</span><span class="p">(</span><span class="n">imb</span><span class="p">))</span>

                    <span class="n">position_desc</span> <span class="o">=</span> <span class="s2">&quot;the beginning&quot;</span>

                <span class="c1"># Case 2: Move after a specific band</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Convert target position to string</span>
                    <span class="n">band_to_position</span> <span class="o">=</span> <span class="n">numpy_to_string_list</span><span class="p">(</span><span class="n">band_to_position</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># Validate band_to_position existence</span>
                    <span class="k">if</span> <span class="n">band_to_position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target position band &#39;</span><span class="si">{</span><span class="n">band_to_position</span><span class="si">}</span><span class="s2">&#39; does not exist. &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># Extract the band(s) to move</span>
                    <span class="n">im_toswitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_bands</span><span class="p">(</span><span class="n">band_to_switch</span><span class="p">)</span>

                    <span class="c1"># Remove those band(s) from the original</span>
                    <span class="n">im_remove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_remove_bands</span><span class="p">(</span><span class="n">band_to_switch</span><span class="p">)</span>

                    <span class="c1"># Split the remaining bands into &quot;before target&quot; and &quot;after target&quot;</span>
                    <span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="n">split_keys</span><span class="p">(</span><span class="n">im_remove</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">band_to_position</span><span class="p">)</span>

                    <span class="c1"># Extract &quot;before target&quot; and &quot;after target&quot; bands</span>
                    <span class="n">imb</span> <span class="o">=</span> <span class="n">im_remove</span><span class="o">.</span><span class="n">__get_bands</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>
                    <span class="n">ima</span> <span class="o">=</span> <span class="n">im_remove</span><span class="o">.</span><span class="n">__get_bands</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>

                    <span class="c1"># Reconstruct image in the new order: before + target + switched + after</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">imb</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">im_toswitch</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">ima</span><span class="p">))</span>

                    <span class="n">position_desc</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;after band &#39;</span><span class="si">{</span><span class="n">band_to_position</span><span class="si">}</span><span class="s2">&#39;&quot;</span>

                <span class="c1"># Add to history if enabled</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__history&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>

                    <span class="n">bands_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">band_to_switch</span><span class="p">)</span>
                    <span class="n">new_order</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Moved band(s) [</span><span class="si">{</span><span class="n">bands_str</span><span class="si">}</span><span class="s1">] to </span><span class="si">{</span><span class="n">position_desc</span><span class="si">}</span><span class="s1">. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Original order: </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">original_order</span><span class="p">)</span><span class="si">}</span><span class="s1">. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;New order: </span><span class="si">{</span><span class="n">new_order</span><span class="si">}</span><span class="s1">.&#39;</span>
                    <span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band switching failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_switch_band</span><span class="p">(</span><span class="n">band_to_switch</span><span class="p">,</span> <span class="n">band_to_position</span><span class="o">=</span><span class="n">band_to_position</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_switch_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_to_switch</span><span class="p">,</span> <span class="n">band_to_position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image with a specified band moved to a new position.</span>

<span class="sd">        This method creates a new Geoimage by moving a specified band to a new</span>
<span class="sd">        position, either at the beginning of the band sequence or after a specific band.</span>
<span class="sd">        Unlike switch_band(), this method doesn&#39;t modify the original image but</span>
<span class="sd">        returns a new one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        band_to_switch : str, int, or list</span>
<span class="sd">            The band(s) to move to a new position. Can be specified as a band name,</span>
<span class="sd">            band index, or a list containing a single band identifier.</span>

<span class="sd">        band_to_position : str, int, or None, optional</span>
<span class="sd">            The target position specification:</span>
<span class="sd">            - If None: Move the band to the first position (beginning of the sequence)</span>
<span class="sd">            - If specified: Move the band to the position immediately after this band</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with the reordered bands.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If specified bands don&#39;t exist or if input parameters are invalid.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create new image with NIR band moved to the beginning</span>
<span class="sd">        &gt;&gt;&gt; original = Geoimage(&quot;multispectral.tif&quot;)</span>
<span class="sd">        &gt;&gt;&gt; nir_first = original.apply_switch_band(&#39;NIR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original bands: {list(original.names.keys())}&quot;)  # Unchanged</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;New bands: {list(nir_first.names.keys())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create new image with SWIR band after Red band</span>
<span class="sd">        &gt;&gt;&gt; swir_after_red = original.apply_switch_band(&#39;SWIR&#39;, &#39;Red&#39;)</span>
<span class="sd">        &gt;&gt;&gt; swir_after_red.save(&#39;reordered.tif&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - When multiple bands should be moved as a unit, provide them in a list</span>
<span class="sd">        as the band_to_switch parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Create a copy of the original image</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Apply band switching to the copy</span>
            <span class="n">result</span><span class="o">.</span><span class="n">switch_band</span><span class="p">(</span><span class="n">band_to_switch</span><span class="p">,</span> <span class="n">band_to_position</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Modify history to clarify this was a non-destructive operation</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;__history&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                <span class="c1"># Find and modify the last history entry (added by switch_band)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;__listhistory&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">:</span>
                    <span class="n">last_entry</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="s2">&quot;Moved band(s)&quot;</span> <span class="ow">in</span> <span class="n">last_entry</span><span class="p">:</span>
                        <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                        <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>

                        <span class="c1"># Parse the band information from the existing entry</span>
                        <span class="n">band_info</span> <span class="o">=</span> <span class="n">last_entry</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;Moved band(s)&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="c1"># Replace with a new entry that clarifies this was a copy operation</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created as a copy with band(s)</span><span class="si">{</span><span class="n">band_info</span><span class="si">}</span><span class="s1">. &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;Original image was not modified.&#39;</span>
                        <span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating image with switched bands failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

<div class="viewcode-block" id="Geoimage.add_band">
<a class="viewcode-back" href="../../modules.html#rastereasy.Geoimage.add_band">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectral_band</span><span class="p">,</span> <span class="n">name_band</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after_band</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new spectral band to the image.</span>

<span class="sd">        This method adds a new spectral band to the current image. The new band can</span>
<span class="sd">        be placed at the end of the band stack (default) or after a specified band.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectral_band : numpy.ndarray</span>
<span class="sd">            The spectral band data to add. Can be in any of the following formats:</span>
<span class="sd">            - 2D array with shape (rows, cols)</span>
<span class="sd">            - 3D array with shape (1, rows, cols)</span>
<span class="sd">            - 3D array with shape (rows, cols, 1)</span>
<span class="sd">            The spatial dimensions must match the current image.</span>

<span class="sd">        name_band : str, optional</span>
<span class="sd">            Name to assign to the new band. If None, a sequential name will be used.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        after_band : str, int, or None, optional</span>
<span class="sd">            Specify where to insert the new band:</span>
<span class="sd">            - If None: Add to the end of the band stack (default)</span>
<span class="sd">            - If str or int: Insert after the specified band name or index</span>
<span class="sd">            Default is None.</span>

<span class="sd">        dtype : str or None, optional</span>
<span class="sd">            Data type for the new band and resulting image. If None, preserves the</span>
<span class="sd">            highest precision type between the current image and the new band.</span>
<span class="sd">            Common values: &#39;float64&#39;, &#39;float32&#39;, &#39;int32&#39;, &#39;uint16&#39;, &#39;uint8&#39;.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy of the image with added band</span>
<span class="sd">            Otherwise, adding band in place and return None.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the updated image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            The modified image with the new band added or None if `inplace=True`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If dimensions don&#39;t match, if the dtype is unknown, or if the after_band</span>
<span class="sd">            doesn&#39;t exist in the image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Add a NDVI band to the end</span>
<span class="sd">        &gt;&gt;&gt; ndvi = (image.select_band(&#39;NIR&#39;) - image.select_band(&#39;Red&#39;) / (image.select_band(&#39;NIR&#39;) + image.select_band(&#39;Red&#39;)</span>
<span class="sd">        &gt;&gt;&gt; image_and_ndvi = image.add_band(ndvi, name_band=&#39;NDVI&#39;)</span>
<span class="sd">        &gt;&gt;&gt; image_and_ndvi.info()  # Shows NDVI as the last band</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Add a band after a specific position</span>
<span class="sd">        &gt;&gt;&gt; image_and_ndvi = image.add_band(thermal_data, name_band=&#39;TIR&#39;, after_band=&#39;NIR&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Add with explicit data type and save</span>
<span class="sd">        &gt;&gt;&gt; image.add_band(elevation, name_band=&#39;DEM&#39;, dtype=&#39;float32&#39;,inplace = True,</span>
<span class="sd">        &gt;&gt;&gt;                dest_name=&#39;with_dem.tif&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method modifies the current image by adding a new band.</span>
<span class="sd">        - The spatial dimensions (rows, cols) of the new band must match the current image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># Track original state for history</span>
            <span class="n">original_band_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span>
            <span class="n">original_bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Reshape input to match expected format (bands, rows, cols)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># Convert 2D (rows, cols) to 3D (1, rows, cols)</span>
                    <span class="n">spectral_band</span> <span class="o">=</span> <span class="n">spectral_band</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Convert 3D (rows, cols, 1) to 3D (1, rows, cols)</span>
                    <span class="n">spectral_band</span> <span class="o">=</span> <span class="n">np2rio</span><span class="p">(</span><span class="n">spectral_band</span><span class="p">)</span>

                <span class="c1"># Validate dimensions match</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                    <span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band dimensions (</span><span class="si">{</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;don&#39;t match image dimensions (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

                <span class="c1"># Add the new band name to the dictionary</span>
                <span class="n">old_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">add_ordered_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">key_name</span><span class="o">=</span><span class="n">name_band</span><span class="p">)</span>

                <span class="c1"># If name_band was auto-generated, get the actual name used</span>
                <span class="k">if</span> <span class="n">name_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Find the new key that wasn&#39;t in the old names</span>
                    <span class="n">new_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">old_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">new_keys</span><span class="p">:</span>
                        <span class="n">name_band</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_keys</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Determine insertion position</span>
                <span class="k">if</span> <span class="n">after_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Add to the end</span>
                    <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span>
                    <span class="n">position_desc</span> <span class="o">=</span> <span class="s2">&quot;the end&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Convert after_band to string if needed</span>
                    <span class="n">after_band</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">after_band</span><span class="p">)</span>

                    <span class="c1"># Validate after_band exists</span>
                    <span class="k">if</span> <span class="n">after_band</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band &#39;</span><span class="si">{</span><span class="n">after_band</span><span class="si">}</span><span class="s2">&#39; not found for &#39;after_band&#39; parameter. &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># Insert after the specified band</span>
                    <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">after_band</span><span class="p">]</span>
                    <span class="n">position_desc</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;after band &#39;</span><span class="si">{</span><span class="n">after_band</span><span class="si">}</span><span class="s2">&#39;&quot;</span>

                <span class="c1"># Determine best dtype if not specified</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Auto-determine dtype based on input data and current image</span>
                    <span class="n">input_dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">current_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>

                    <span class="c1"># Simple dtype precedence (higher precision wins)</span>
                    <span class="n">dtype_precedence</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;float64&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;int64&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                        <span class="s1">&#39;uint32&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;int8&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;uint8&#39;</span><span class="p">:</span> <span class="mi">9</span>
                    <span class="p">}</span>

                    <span class="c1"># Choose the dtype with higher precision</span>
                    <span class="k">if</span> <span class="n">dtype_precedence</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">,</span> <span class="mi">999</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dtype_precedence</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">current_dtype</span><span class="p">,</span> <span class="mi">999</span><span class="p">):</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">input_dtype</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">current_dtype</span>

                <span class="c1"># Convert to numpy dtype for consistent handling</span>
                <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

                <span class="c1"># Insert the new band at the specified position</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np_dtype</span><span class="p">),</span>
                    <span class="n">position</span><span class="p">,</span>
                    <span class="n">spectral_band</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np_dtype</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>

                <span class="c1"># Update metadata</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np_dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">()</span>

                <span class="c1"># Save if requested</span>
                <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">write_geoim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">,</span> <span class="n">dest_name</span><span class="p">)</span>

                <span class="c1"># Update history if enabled</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Added band &quot;</span><span class="si">{</span><span class="n">name_band</span><span class="si">}</span><span class="s1">&quot; at </span><span class="si">{</span><span class="n">position_desc</span><span class="si">}</span><span class="s1">. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Original bands: </span><span class="si">{</span><span class="n">original_band_count</span><span class="si">}</span><span class="s1">, New total: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span><span class="si">}</span><span class="s1">. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Data type: </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s1">.&#39;</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Image with added band saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding band failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__apply_add_band</span><span class="p">(</span><span class="n">spectral_band</span><span class="p">,</span> <span class="n">name_band</span><span class="o">=</span><span class="n">name_band</span><span class="p">,</span> <span class="n">after_band</span><span class="o">=</span><span class="n">after_band</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="n">dest_name</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__apply_add_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectral_band</span><span class="p">,</span> <span class="n">name_band</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after_band</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new image with an additional spectral band.</span>

<span class="sd">        This method creates a new Geoimage with an additional band, without</span>
<span class="sd">        modifying the original image. The new band can be placed at the end</span>
<span class="sd">        of the band stack (default) or after a specified band.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spectral_band : numpy.ndarray</span>
<span class="sd">            The spectral band data to add. Can be in any of the following formats:</span>
<span class="sd">            - 2D array with shape (rows, cols)</span>
<span class="sd">            - 3D array with shape (1, rows, cols)</span>
<span class="sd">            - 3D array with shape (rows, cols, 1)</span>
<span class="sd">            The spatial dimensions must match the current image.</span>

<span class="sd">        name_band : str, optional</span>
<span class="sd">            Name to assign to the new band. If None, a sequential name will be used.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        after_band : str, int, or None, optional</span>
<span class="sd">            Specify where to insert the new band:</span>
<span class="sd">            - If None: Add to the end of the band stack (default)</span>
<span class="sd">            - If str or int: Insert after the specified band name or index</span>
<span class="sd">            Default is None.</span>

<span class="sd">        dtype : str or None, optional</span>
<span class="sd">            Data type for the new band and resulting image. If None, preserves the</span>
<span class="sd">            highest precision type between the current image and the new band.</span>
<span class="sd">            Common values: &#39;float64&#39;, &#39;float32&#39;, &#39;int32&#39;, &#39;uint16&#39;, &#39;uint8&#39;.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        dest_name : str, optional</span>
<span class="sd">            Path to save the new image. If None, the image is not saved.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geoimage</span>
<span class="sd">            A new Geoimage with the additional band.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If dimensions don&#39;t match, if the dtype is unknown, or if the after_band</span>
<span class="sd">            doesn&#39;t exist in the image.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Create a new image with an additional NDVI band</span>
<span class="sd">        &gt;&gt;&gt; with_ndvi = image.__apply_add_band(ndvi, name_band=&#39;NDVI&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original bands: {list(image.names.keys())}&quot;)  # Unchanged</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;New bands: {list(with_ndvi.names.keys())}&quot;)  # Has NDVI band</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Add a band after a specific position</span>
<span class="sd">        &gt;&gt;&gt; with_tir = image.__apply_add_band(thermal_data, name_band=&#39;TIR&#39;, after_band=&#39;NIR&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Add with explicit data type and save</span>
<span class="sd">        &gt;&gt;&gt; with_dem = image.__apply_add_band(elevation, name_band=&#39;DEM&#39;, dtype=&#39;float32&#39;,</span>
<span class="sd">        &gt;&gt;&gt;                                 dest_name=&#39;with_dem.tif&#39;)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The spatial dimensions (rows, cols) of the new band must match the current image.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Track original state for documentation</span>
        <span class="n">original_band_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_bands</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Reshape input to match expected format (bands, rows, cols)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Convert 2D (rows, cols) to 3D (1, rows, cols)</span>
                <span class="n">spectral_band</span> <span class="o">=</span> <span class="n">spectral_band</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Convert 3D (rows, cols, 1) to 3D (1, rows, cols)</span>
                <span class="n">spectral_band</span> <span class="o">=</span> <span class="n">np2rio</span><span class="p">(</span><span class="n">spectral_band</span><span class="p">)</span>

            <span class="c1"># Validate dimensions match</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                <span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band dimensions (</span><span class="si">{</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;don&#39;t match image dimensions (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

            <span class="c1"># Create copy of names to avoid modifying the original</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Add the new band name to the dictionary</span>
            <span class="n">old_names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">add_ordered_key</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">key_name</span><span class="o">=</span><span class="n">name_band</span><span class="p">)</span>

            <span class="c1"># If name_band was auto-generated, get the actual name used</span>
            <span class="k">if</span> <span class="n">name_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Find the new key that wasn&#39;t in the old names</span>
                <span class="n">new_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">old_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">new_keys</span><span class="p">:</span>
                    <span class="n">name_band</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_keys</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Copy metadata</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Create a copy of the original image to avoid modifying it</span>
            <span class="n">image_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Determine insertion position</span>
            <span class="k">if</span> <span class="n">after_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Add to the end (concatenate)</span>
                <span class="n">position_desc</span> <span class="o">=</span> <span class="s2">&quot;the end&quot;</span>

                <span class="c1"># Determine best dtype if not specified</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Auto-determine dtype based on input data and current image</span>
                    <span class="n">input_dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">current_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>

                    <span class="c1"># Simple dtype precedence (higher precision wins)</span>
                    <span class="n">dtype_precedence</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;float64&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;int64&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                        <span class="s1">&#39;uint32&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;int8&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;uint8&#39;</span><span class="p">:</span> <span class="mi">9</span>
                    <span class="p">}</span>

                    <span class="c1"># Choose the dtype with higher precision</span>
                    <span class="k">if</span> <span class="n">dtype_precedence</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">,</span> <span class="mi">999</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dtype_precedence</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">current_dtype</span><span class="p">,</span> <span class="mi">999</span><span class="p">):</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">input_dtype</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">current_dtype</span>

                <span class="c1"># Convert to numpy dtype for consistent handling</span>
                <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

                <span class="c1"># Concatenate the new band at the end</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">image_copy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np_dtype</span><span class="p">),</span>
                    <span class="n">spectral_band</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np_dtype</span><span class="p">)),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Convert after_band to string if needed</span>
                <span class="n">after_band</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">after_band</span><span class="p">)</span>

                <span class="c1"># Validate after_band exists</span>
                <span class="k">if</span> <span class="n">after_band</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">available</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Band &#39;</span><span class="si">{</span><span class="n">after_band</span><span class="si">}</span><span class="s2">&#39; not found for &#39;after_band&#39; parameter. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Available bands are: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Determine position for insertion</span>
                <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">after_band</span><span class="p">]</span>
                <span class="n">position_desc</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;after band &#39;</span><span class="si">{</span><span class="n">after_band</span><span class="si">}</span><span class="s2">&#39;&quot;</span>

                <span class="c1"># Determine best dtype if not specified</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Auto-determine dtype based on input data and current image</span>
                    <span class="n">input_dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">spectral_band</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">current_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>

                    <span class="c1"># Simple dtype precedence (higher precision wins)</span>
                    <span class="n">dtype_precedence</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;float64&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;int64&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                        <span class="s1">&#39;uint32&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;uint16&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;int8&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;uint8&#39;</span><span class="p">:</span> <span class="mi">9</span>
                    <span class="p">}</span>

                    <span class="c1"># Choose the dtype with higher precision</span>
                    <span class="k">if</span> <span class="n">dtype_precedence</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">,</span> <span class="mi">999</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dtype_precedence</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">current_dtype</span><span class="p">,</span> <span class="mi">999</span><span class="p">):</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">input_dtype</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">current_dtype</span>

                <span class="c1"># Convert to numpy dtype for consistent handling</span>
                <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

                <span class="c1"># Insert the new band at the specified position</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="n">image_copy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np_dtype</span><span class="p">),</span>
                    <span class="n">position</span><span class="p">,</span>
                    <span class="n">spectral_band</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np_dtype</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>

            <span class="c1"># Update metadata</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np_dtype</span><span class="p">)</span>

            <span class="c1"># Create new Geoimage with added band</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Geoimage</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">georef</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__georef</span><span class="p">)</span>

            <span class="c1"># Initialize history if enabled</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__history&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">activate_history</span><span class="p">()</span>

                <span class="c1"># Copy existing history if available</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__listhistory&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># Add band addition entry to history</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="n">now_str</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>

                <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="n">now_str</span><span class="si">}</span><span class="s1">] - Created as a copy with additional band &quot;</span><span class="si">{</span><span class="n">name_band</span><span class="si">}</span><span class="s1">&quot; at </span><span class="si">{</span><span class="n">position_desc</span><span class="si">}</span><span class="s1">. &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;Original bands: </span><span class="si">{</span><span class="n">original_band_count</span><span class="si">}</span><span class="s1">, New total: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">nb_bands</span><span class="si">}</span><span class="s1">. &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;Data type: </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s1">. Original image was not modified.&#39;</span>
                <span class="p">)</span>

            <span class="c1"># Save if requested</span>
            <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">__history</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">__listhistory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> New image saved to: </span><span class="si">{</span><span class="n">dest_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating image with additional band failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Thomas Corpetti.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>